%\chapter{Overview of Scheme}
\chapter{Введение в Scheme}
\label{semanticchapter}

%This chapter gives an overview of Scheme's semantics.
%The purpose of this overview is to explain
%enough about the basic concepts of the language to facilitate
%understanding of the subsequent chapters of the report, which are
%organized as a reference manual.  Consequently, this overview is
%not a complete introduction to the language, nor is it precise
%in all respects or normative in any way.
В данной главе описано введение в семантику Scheme. Целью данного введения является объяснение
фундаментальных концепций языка, достаточных для облегчения понимания последующих глав работы,
организованных в виде справочного руководства. Поэтому данный краткий обзор не является полным
введением в язык, и при этом он не всегда точен в некоторых аспектах или не всегда нормативен.

%\vest Following Algol, Scheme is a statically scoped programming
%language.  Each use of a variable is associated with a lexically
%apparent binding of that variable.
После Algol Scheme является языком программирования со статическими областями
видимости. Каждое использование переменной ассоциировано с лексически явным
связыванием этой переменной.

%\vest Scheme has latent as opposed to manifest types
%\cite{WaiteGoos}.  Types
%are associated with objects\mainindex{object} (also called values) rather than
%with variables.  (Some authors refer to languages with latent types as
%untyped, weakly typed or dynamically typed languages.)  Other languages with
%latent types are Python, Ruby, Smalltalk, and other dialects of Lisp.  Languages
%with manifest types (sometimes referred to as strongly typed or
%statically typed languages) include Algol 60, C, C\#, Java, Haskell, and ML.
\vest Scheme имеет неявные, в отличие от декларативных, типы\cite{WaiteGoos}. Типы связаны с
объектами\mainindex{object} (также называемыми значениями), а не с переменными. (Некоторые
авторы называют языки с неявными типами нетипизированными, слабо типизированными или динамически
типизированными языками.) Другими языками с неявными типами являются Python, Ruby, Smalltalk, а
также другие диалекты Lisp. Языки с декларативными типами (иногда называемые строго
типизированными или статически типизированными языками) включают Algol 60, C, C\#, Java, Haskell
и ML.

%\vest All objects created in the course of a Scheme computation, including
%procedures and continuations, have unlimited extent.
%No Scheme object is ever destroyed.  The reason that
%implementations of Scheme do not (usually!)\ run out of storage is that
%they are permitted to reclaim the storage occupied by an object if
%they can prove that the object cannot possibly matter to any future
%computation.  Other languages in which most objects have unlimited
%extent include C\#, Java, Haskell, most Lisp dialects, ML, Python,
%Ruby, and Smalltalk.
\vest Все объекты, созданные в процессе вычисления Scheme, включая процедуры и продолжения,
имеют неограниченный экстент. Ни один объект Scheme никогда не разрушается. Причина того, что
реализации Scheme полностью не расходуют (обычно!)\ память, состоит в том, что им разрешается
возвращать память, занятую объектом, если они смогут выяснить, что объект не имеет возможности
влиять ни на одно будущее вычисление. Другие языки, в которых большинство объектов имеет
неограниченный экстент, включают C\#, Java, Haskell, большинство диалектов Lisp, ML, Python,
Ruby и Smalltalk.

%Implementations of Scheme must be properly tail-recursive.
%This allows the execution of an iterative computation in constant space,
%even if the iterative computation is described by a syntactically
%recursive procedure.  Thus with a properly tail-recursive implementation,
%iteration can be expressed using the ordinary procedure-call
%mechanics, so that special iteration constructs are useful only as
%syntactic sugar.
Реализации Scheme должны подчиняться правилам хвостовой рекурсии. Это даёт возможность
выполнения итеративного вычисления в постоянном пространстве, даже если итеративное вычисление
описано синтаксически рекурсивной процедурой. Таким образом, при реализации
поддержки хвостовой рекурсии, итерация может быть выражена с помощью обычной техники вызова
процедуры, так, чтобы специальные итеративные конструкции были применимы только в качестве
синтаксического сахара.

%\vest Scheme was one of the first languages to support procedures as
%objects in their own right.  Procedures can be created dynamically,
%stored in data structures, returned as results of procedures, and so
%on.  Other languages with these properties include Common Lisp,
%Haskell, ML, Ruby, and Smalltalk.
\vest Scheme был одним из первых языков, поддерживающих процедуры как объекты сами по себе.
Процедуры могут динамически создаваться, сохраняться в структурах данных, возвращаться как
результаты процедур, и так далее. Другие языки с этими свойствами включают Common Lisp,
Haskell, ML, Ruby и Smalltalk.

%\vest One distinguishing feature of Scheme is that continuations, which
%in most other languages only operate behind the scenes, also have
%``first-class'' status.  First-class continuations are useful for implementing a
%wide variety of advanced control constructs, including non-local exits,
%backtracking, and coroutines.
\vest Одной из отличительных особенностей Scheme является то, что продолжения, которые в
большинстве других языков функционируют только внутренне, также имеют "первоклассный"
статус. Первоклассные продолжения полезны для реализации широкого разнообразия передовых
управляющих конструкций, включая нелокальные выходы, бектрекинг и сопрограммы.

%\newpage

%In Scheme, the argument expressions of a procedure call are evaluated
%before the procedure gains control, whether the procedure needs the
%result of the evaluation or not.  C, C\#, Common Lisp, Python,
%Ruby, and Smalltalk are other languages that always evaluate argument
%expressions before invoking a procedure.  This is distinct from the
%lazy-evaluation semantics of Haskell, or the call-by-name semantics of
%Algol 60, where an argument expression is not evaluated unless its
%value is needed by the procedure.
Выражения аргументов вызова процедуры в Scheme вычисляются перед получением процедурой
управления независимо от необходимости для процедуры результата вычисления.
C, C\#, Common Lisp, Python, Ruby и Smalltalk - другие языки, которые всегда вычисляют выражения
аргументов перед вызовом процедуры. Это отличается от семантики ленивого вычисления Haskell или
семантики вызова по имени Algol 60, где выражение аргумента не вычисляется, если процедура не
нуждается в его значении.\vspace{1mm}

%Scheme's model of arithmetic provides a rich set of numerical types
%and operations on them.  Furthermore, it distinguishes \textit{exact}
%and \textit{inexact} number objects: Essentially, an exact number
%object corresponds to a number exactly, and an inexact number object
%is the result of a computation that involved rounding or other errors.
Арифметическая модель Scheme предоставляет богатый набор численных типов и операций с
ними. Кроме того, она различает \textit{точные} и \textit{неточные} числовые объекты: По
существу, точный числовой объект точно соответствует числу, а неточный числовой объект является
результатом вычисления, которое повлекло за собой округление или другие ошибки.\vspace{1mm}

%\section{Basic types}
\section{Основные типы}\vspace{1mm}

%Scheme programs manipulate \textit{objects}, which are also referred
%to as \textit{values}.
%Scheme objects are organized into sets of values called \textit{types}.
%This section gives an overview of the fundamentally important types of the
%Scheme language.  More types are described in later chapters.
Программы Scheme оперируют \textit{объектами}, которые также называются
\textit{значениями}. Объекты Scheme организованы в наборы значений, которые называются
\textit{типами}. В этой секции дан краткий обзор существенно важных типов языка Scheme. Больше
типов описано в последующих главах.\vspace{1mm}

\begin{note}
  %As Scheme is latently typed, the use of the term \textit{type} in
  %this report differs from the use of the term in the context of other
  %languages, particularly those with manifest typing.
  Поскольку Scheme латентно типизирован, использование термина \textit{тип} в данной работе
  отличается от использования термина в контексте других языков, особенно с явно объявляемой
  типизацией.
\end{note}

%\paragraph{Booleans}
\paragraph{Булевые}\vspace{1mm}

%\mainindex{boolean}A boolean is a truth value, and can be either
%true or false.  In Scheme, the object for ``false'' is written
%\schfalse{}.  The object for ``true'' is written \schtrue{}.  In
%most places where a truth value is expected, however, any object different from
%\schfalse{} counts as true.
\mainindex{boolean}Булевый тип является истинностным значением и может быть true или
false. Объект ``false'' в Scheme записывается \schfalse{}.  Объект ``true'' записывается
\schtrue{}. В большинстве мест, где ожидается истинностное значение, однако, любой объект,
отличный от \schfalse{} интерпретитуется как true.\vspace{1mm}

%\paragraph{Numbers}
\paragraph{Числовые}\vspace{1mm}

%\mainindex{number}Scheme supports a rich variety of numerical data types, including
%objects representing integers of arbitrary precision, rational numbers, complex numbers, and
%inexact numbers of various kinds.  Chapter~\ref{numbertypeschapter} gives an
%overview of the structure of Scheme's numerical tower
\mainindex{number}Scheme поддерживает множество числовых типов данных, включая
объекты, представляющие целые числа произвольной точности, рациональные числа, сложные числа и
приближённые числа различных видов. В Главе~\ref{numbertypeschapter} дан краткий обзор структуры
башни численных типов Scheme.\vspace{1mm}

%\paragraph{Characters}
\paragraph{Символьные}\vspace{1mm}

%\mainindex{character}Scheme characters mostly correspond to textual characters.
%More precisely, they are isomorphic to the \textit{scalar values} of
%the Unicode standard.
Символы Scheme по большей части соответствуют текстовым символам. Более точно,
они изоморфны к скалярным величинам стандарта Unicode.

%\paragraph{Strings}
\paragraph{Строковые}

%\mainindex{string}Strings are finite sequences of characters with fixed length and thus
%represent arbitrary Unicode texts.
\mainindex{string}Строки являются конечными последовательностями символов фиксированной длины и,
таким образом, представляют произвольные тексты Unicode.

%\newpage

%\paragraph{Symbols}
\paragraph{Символьные}

%\mainindex{symbol}A symbol is an object representing a string,
%the symbol's \textit{name}.
%Unlike strings, two symbols whose names are spelled the same
%way are never distinguishable.  Symbols are useful for many applications;
%for instance, they may be used the way enumerated values are used in
%other languages.
Символ является объектом, представляющим строку, \textit{имя} символа. В отличие от строки, два символа,
имена которых записаны в том же порядке, никоим образом не различаются. Символы полезны для
многих применений; например, они могут использоваться, перечислимые значения пути
используются на других языках.

%\paragraph{Pairs and lists}
\paragraph{Пары и списки}

\mainindex{pair}\mainindex{list}
%A pair is a data structure with two components.  The most common use
%of pairs is to represent (singly linked) lists, where the first
%component (the ``car'') represents the first element of the list, and
%the second component (the ``cdr'') the rest of the list.  Scheme also
%has a distinguished empty list, which is the last cdr in a chain of
%pairs that form a list.
Пара является структурой данных с двумя компонентами. Наиболее общее применение пар относится
к представлению (отдельно связанных) списков, где первый компонент ("car") представляет первый
элемент списка, а второй компонент ("cdr") - остальную часть списка. Scheme также имеет
отдельный пустой список, который является последним cdr в цепочке пар, формирующих
список.

%\paragraph{Vectors}
\paragraph{Векторы}

%\mainindex{vector}Vectors, like lists, are linear data structures
%representing finite sequences of arbitrary objects.
%Whereas the elements of a list are accessed
%sequentially through the chain of pairs representing it,
%the elements of a vector are addressed by integer indices.
%Thus, vectors are more appropriate than
%lists for random access to elements.
\mainindex{vector}Векторы, как и списки, являются линейными структурами данных, представляющими конечные
последовательности произвольных объектов. Поскольку к элементам списка получают
доступ последовательно через цепь пар, представляющих его, к элементам вектора обращаются
целыми индексами. Таким образом, векторы предпочтительнее списков для
произвольного доступа к элементам.

%\paragraph{Procedures}
\paragraph{Процедуры}

%\mainindex{procedure}Procedures are values in Scheme.
\mainindex{procedure}В Scheme процедуры являются значениями.

%\section{Expressions}
\section{Выражения}

%The most important elements of Scheme code are
%\mainindex{expression}\textit{expressions}.  Expressions can be
%\textit{evaluated}, producing a \textit{value}.  (Actually, any number
%of values---see section~\ref{multiplereturnvaluessection}.)  The most
%fundamental expressions are literal expressions:
Важнейшими элементами кода Scheme являются \mainindex{expression}\textit{выражения}. Выражения
могут быть \textit{вычислены}, порождая \textit{значение}. (Фактически, любое количество
значений---см. раздел~\ref{multiplereturnvaluessection}.) Самые фундаментальные выражения -
литеральные выражения:\vspace{1mm}

\begin{scheme}
\bfseries{\schtrue{}} \ev \bfseries{\schtrue}
\bfseries{23} \ev \bfseries{23}%
\end{scheme}\vspace{1mm}

%This notation means that the expression \schtrue{} evaluates to
%\schtrue{}, that is, the value for ``true'',  and that the expression
%{\cf 23} evaluates to a number object representing the number 23.
Эта форма записи означает, что выражение \schtrue {} вычисляется как
\schtrue {}, то есть, значение для ``true'', и что выражение {\cf 23} вычисляется к
численному объекту, представляющему число 23.\vspace{1mm}

%Compound expressions are formed by placing parentheses around their
%subexpressions.  The first subexpression identifies an operation; the
%remaining subexpressions are operands to the operation:
Составные выражения формируются помещением круглых скобок вокруг своих подвыражений. Первое
подвыражение идентифицирует операцию; остальные подвыражения являются операндами
операции:\vspace{1mm}
%
\begin{scheme}
\bfseries{(+ 23 42)} \ev \bfseries{65}
\bfseries{(+ 14 (* 23 42))} \ev \bfseries{980}%
\end{scheme}\vspace{1mm}
%
%In the first of these examples, {\cf +} is the name of
%the built-in operation for addition, and {\cf 23} and {\cf 42} are the
%operands.  The expression {\cf (+ 23 42)} reads as ``the sum of 23 and
%42''.  Compound expressions can be nested---the second example reads
%as ``the sum of 14 and the product of 23 and 42''.
В начале этого примера {\bfseries\cf +} является именем встроенной операции сложения, а
{\bfseries\cf 23} и {\bfseries\cf 42} - операндами. Выражение {\bfseries\cf (+ 23 42)}
читается как ``сумма 23 и 42''. Составные выражения могут вкладываться---следующий пример
читается как ``сумма 14 и произведения 23 и 42''.\vspace{1mm}

%As these examples indicate, compound expressions in Scheme are always
%written using the same prefix notation\mainindex{prefix notation}.  As
%a consequence, the parentheses are needed to indicate structure.
%Consequently, ``superfluous'' parentheses, which are often permissible in
%mathematical notation and also in many programming languages, are not
%allowed in Scheme.
Как показывают эти примеры, составные выражения в Scheme всегда записываются с помощью одной и
той же префиксной нотации\mainindex{prefix notation}. Следствием является необходимость круглых
скобок для указания структуры. Следовательно, ``лишние'' круглые скобки, которые часто
допускаются в математической нотации, а также во многих языках программирования, в Scheme не
позволяются.

%As in many other languages, whitespace (including line endings) is not
%significant when it separates subexpressions of an expression, and
%can be used to indicate structure.
Как и во многих других языках, пробельные символы (включая конец строки) являются не значащими,
когда они отделяют подвыражения выражений, и могут использоваться для указания структуры.

%\section{Variables and binding}
\section{Переменные и привязка}

%\mainindex{variable}\mainindex{binding}\mainindex{identifier}Scheme
%allows identifiers to stand for locations containing values.
%These identifiers are called variables.  In many cases, specifically
%when the location's value is never modified after its creation, it is
%useful to think of the variable as standing for the value directly.
\mainindex{variable}\mainindex{binding}\mainindex{identifier}Scheme позволяет привязывать
идентификаторы к содержащим значения ячейкам памяти. Такие идентификаторы называются
переменными. Во многих случаях, определенно когда значение ячейки памяти никогда не изменяется
после её создания, полезно думать о переменной как привязанной к значению непосредственно.\vspace{1mm}

\begin{scheme}
\bfseries(let ((x 23)
\bfseries      (y 42))
\bfseries  (+ x y)) \ev \textbf{65}%
\end{scheme}\vspace{1mm}

%In this case, the expression starting with {\cf let} is a binding
%construct.  The parenthesized structure following the {\cf let} lists
%variables alongside expressions: the variable {\cf x} alongside {\cf
%  23}, and the variable {\cf y} alongside {\cf 42}.  The {\cf let}
%expression binds {\cf x} to 23, and {\cf y} to 42.  These bindings are
%available in the \textit{body} of the {\cf let} expression, {\cf (+ x
%  y)}, and only there.
В данном случае выражение, начинающееся с {\cf\bfseries let} является конструкцией привязки. В
окружённой скобками структуре после {\cf\bfseries let} перечислены переменные совместно с выражениями:
переменная {\cf\bfseries x} совместно с {\cf\bfseries 23} и переменная {\cf\bfseries y}
совместно с {\cf\bfseries 42}. Выражение {\cf\bfseries let} связывает {\cf\bfseries x} с 23 и
{\cf\bfseries y} c 42. Эти привязки доступны в \textit{теле} выражения {\cf\bfseries let},
{\cf\bfseries (+ x y)}, и только там.

%\section{Definitions}
\section{Определения}\vspace{1mm}

%\index{definition}The variables bound by a {\cf let} expression
%are \textit{local}, because their bindings are visible only in the
%{\cf let}'s body.  Scheme also allows creating top-level bindings for
%identifiers as follows:
\index{definition}Переменные, связанные выражением {\cf\bfseries let}, являются
\textit{локальными}, так как их связывания видимы только в теле {\cf\bfseries let}. Scheme также
позволяет создавать связывания верхнего уровня для идентификаторов следующим образом:\vspace{1mm}

\begin{scheme}
\bfseries(define x 23)
\bfseries(define y 42)
\bfseries(+ x y) \ev \textbf{65}%
\end{scheme}\vspace{1mm}

%(These are actually ``top-level'' in the body of a top-level program or library;
%see section~\ref{librariesintrosection} below.)
(Они фактически являются "верхним уровнем" в теле программы верхнего уровня или библиотеки; см. секцию
~\ref {librariesintrosection} ниже.)

%The first two parenthesized structures are \textit{definitions}; they
%create top-level bindings, binding {\cf x} to 23 and {\cf y} to 42.
%Definitions are not expressions, and cannot appear in all places
%where an expression can occur.  Moreover, a definition has no value.
Первые две заключенные в скобки структуры являются \textit {определениями}; они создают
привязки верхнего уровня, связывая {\cf x} с 23, а {\cf y} с 42. Определения не являются
выражениями и не могут находиться там, тде где может находиться выражение.
Кроме того, определение не имеет значения.

%Bindings follow the lexical structure of the program:  When several
%bindings with the same name exist, a variable refers to the binding
%that is closest to it, starting with its occurrence in the program
%and going from inside to outside, and referring to a top-level
%binding if no
%local binding can be found along the way:
Привязки подчиняются лексической структуре программы: при наличии нескольких одноименных
привязок переменная соотносится с ближайшей к ней на пути изнутри снаружу привязкой, начиная от
её появления в программе, и с привязкой верхнего уровня, если локальная привязка не может быть
найдена на этом пути:\vspace{1mm}

\begin{scheme}
\bfseries(define x 23)
\bfseries(define y 42)
\bfseries(let ((y 43))
%\end{scheme}
%
%\newpage
%
%\begin{scheme}
\bfseries  (+ x y)) \ev \textbf{66}

\bfseries(let ((y 43))
\bfseries  (let ((y 44))
\bfseries    (+ x y))) \ev \textbf{67}%
\end{scheme}

%\section{Forms}
\section{Формы}

%While definitions are not expressions, compound expressions and
%definitions exhibit similar syntactic structure:
Хотя определения не являются выражениями, составные выражения и определения
имеют схожую синтаксическую структуру:
%
\begin{scheme}
\bfseries(define x 23)
\bfseries(* x 2)%
\end{scheme}
%
%While the first line contains a definition, and the second an
%expression, this distinction depends on the bindings for {\cf define}
%and {\cf *}.  At the purely syntactical level, both are
%\textit{forms}\index{form}, and \textit{form} is the general name for
%a syntactic part of a Scheme program.  In particular, {\cf 23} is a
%\textit{subform}\index{subform} of the form {\cf (define x 23)}.
При этом первая линия содержит определение, а следующая - выражение, данное различие
основывается на связывании {\cf\bfseries define} и {\cf\bfseries *}. На чисто синтаксическом
уровне обе являются \textit{формами}\index{form}, а \textit{форма} является обобщённым названием
синтаксической части программы Scheme. В частности, {\cf\bfseries 23} является
\textit{подформой} \index{subform} формы {\cf\bfseries (define x 23)}.

%\section{Procedures}
\section{Процедуры}
\label{proceduressection}

%\index{procedure}Definitions can also be used to define
%procedures:
\index{procedure}Определения могут также использоваться для определения процедур.

\begin{scheme}
\bfseries(define (f x)
\bfseries  (+ x 42))

\bfseries(f 23) \ev \textbf{65}%
\end{scheme}

%A procedure is, slightly simplified, an abstraction of an
%expression over objects.  In the example, the first definition defines a procedure
%called {\cf f}.  (Note the parentheses around {\cf f x}, which
%indicate that this is a procedure definition.)  The expression {\cf (f
%  23)} is a \index{procedure call}procedure call, meaning,
%roughly, ``evaluate {\cf (+ x 42)} (the body of the procedure) with
%{\cf x} bound to 23''.
Процедура, несколько упрощённо, является абстракцией выражения посредством объектов. В первом определении
примера определена процедура, названная {\cf\bfseries f}. (Обратите внимание на круглые скобки
вокруг {\cf\bfseries f x}, обозначающие, что это - определение процедуры.) Выражение
{\cf\bfseries (f 23)} является \index{procedure call} вызовом процедуры, приблизительно означающим
"вычислить {\cf\bfseries (+ x 42)} (тело процедуры) с {\cf\bfseries x}, привязанным к \textbf{23}".

%As procedures are objects, they can be passed to other
%procedures:
Поскольку процедуры являются объектами, их можно передавать в другие процедуры:

%
\begin{scheme}
\bfseries(define (f x)
\bfseries  (+ x 42))

\bfseries(define (g p x)
\bfseries  (p x))

\bfseries(g f 23) \ev \textbf{65}%
\end{scheme}

%In this example, the body of {\cf g} is evaluated with {\cf p}
%bound to {\cf f} and {\cf x} bound to 23, which is equivalent
%to {\cf (f 23)}, which evaluates to 65.
В этом примере тело {\cf\bfseries g} вычисляется с {\cf\bfseries p}, привязанным к {\cf\bfseries
  f}, и {\cf\bfseries x}, привязанным к \textbf{23}, что эквивалентно {\cf\bfseries (f 23)} и
вычисляется как \textbf{65}.

%In fact, many predefined operations of Scheme are provided not by
%syntax, but by variables whose values are procedures.
%The {\cf +} operation, for example, which receives
%special syntactic treatment in many other languages, is just a regular
%identifier in Scheme, bound to a procedure that adds number objects.  The
%same holds for {\cf *} and many others:
Фактически многие предопределённые операции Scheme обеспечиваются не синтаксисом, а
переменными, значениями которых являются процедуры. Операция {\cf\bfseries +}, например, приобретающая
специальную синтаксическую трактовку во многих других языках, в Scheme является всего лишь
регулярным идентификатором, связанным с процедурой, складывающей числовые объекты.
То же самое касается и {\cf\bfseries *}, и многих других:

\begin{scheme}
\bfseries(define (h op x y)
\bfseries  (op x y))

\bfseries(h + 23 42) \ev \textbf{65}
\bfseries(h * 23 42) \ev \textbf{966}%
\end{scheme}

%Procedure definitions are not the only way to create procedures.  A
%{\cf lambda} expression creates a new procedure as an object, with no
%need to specify a name:
Определения процедур - не единственный способ создания процедур. {\cf\bfseries lambda}-выражение
создаёт новую процедуру в качестве объекта без необходимости указания имени:

\begin{scheme}
\bfseries((lambda(x)(+ x 42))23) \ev \textbf{65}%
\end{scheme}

%The entire expression in this example is a procedure call; {\cf
%  (lambda (x) (+ x 42))}, evaluates to a procedure that takes a single
%number object and adds 42 to it.
Всё выражение в этом примере является вызовом процедуры; {\cf\bfseries (lambda (x) (+ x 42))}
вычисляется как процедура, принимающая одиночный числовой объект и добавляющая к нему 42.

%\section{Procedure calls and syntactic keywords}
\section{Вызовы процедур и синтаксические ключевые слова}

%Whereas {\cf (+ 23 42)}, {\cf (f 23)}, and {\cf ((lambda (x) (+ x 42))
%  23)} are all examples of procedure calls, {\cf lambda} and {\cf
%  let} expressions are not.  This is because {\cf let}, even though
%it is an identifier, is not a variable, but is instead a \textit{syntactic
%  keyword}\index{syntactic keyword}.  A form that has a
%syntactic keyword as its first subexpression obeys special rules determined by
%the keyword.  The {\cf define} identifier in a definition is also a
%syntactic keyword.  Hence, definitions are also not procedure calls.
Хотя и {\cf\bfseries (+ 23 42)}, и {\cf\bfseries (f 23)}, и {\cf\bfseries ((lambda (x) (+ x 42))
  23)} являются примерами вызовов процедур, выражения {\cf\bfseries lambda} и {\cf\bfseries let} -
нет. Это потому что {\cf\bfseries let}, хоть и идентификатор, но
не переменная, а \textit{синтаксическое ключевое слово}\index{syntactic
  keyword}. Форма, содежащая синтаксическое ключевое слово в качестве своего первого подвыражения,
подчиняется специальным правилам, определяемым ключевым словом. Идентификатор {\cf\bfseries
  define} в определении также является синтаксическим ключевым словом. Следовательно,
определения также не являются вызовами процедур.

%The rules for the {\cf lambda} keyword specify that the first
%subform is a list of parameters, and the remaining subforms are the body of
%the procedure.  In {\cf let} expressions, the first subform is a list
%of binding specifications, and the remaining subforms constitute a body of
%expressions.
Правилами для ключевого слова {\cf\bfseries lambda} определено, что первая подформа является
списком параметров, а остальные подформы - телом процедуры. В выражении {\cf\bfseries let}
первая подформа является списком спецификаций привязки, а остальные подформы образовывают тело
выражений.

%Procedure calls can generally be distinguished from these
%\textit{special forms}\mainindex{special form} by
%looking for a syntactic keyword in the first position of an
%form: if the first position does not contain a syntactic keyword, the expression
%is a procedure call.
%(So-called \textit{identifier macros} allow creating other kinds of
%special forms, but are comparatively rare.)
%The set of syntactic keywords of Scheme is
%fairly small, which usually makes this task fairly simple.
%It is possible, however, to create new bindings for syntactic keywords; see
%section~\ref{macrosintrosection} below.
Обычно вызовы процедур можно отличить от таких \textit{специальных форм} \mainindex{special
  form}, с помощью поиска синтаксического ключевого слова в первом положении формы: если
в первое положении не содержится синтаксического ключевого слова, выражение является вызовом
процедуры. (Так называемый \textit {макрос идентификатора} позволяет создавать
другие виды специальных форм, но сравнительно редко.) Набор синтаксических ключевых слов Scheme
является довольно небольшим, что обычно делает эту задачу довольно простой. Возможно,
однако, создание новых привязок для синтаксических ключевых слов;
см. секцию~\ref{macrosintrosection} ниже.

%\section{Assignment}
\section{Присваивание}

%Scheme variables bound by definitions or {\cf let} or {\cf lambda}
%expressions are not actually bound directly to the objects specified in the
%respective bindings, but to locations containing these objects.  The
%contents of these locations can subsequently be modified destructively
%via \textit{assignment}\index{assignment}:
Переменные Scheme, связанные с определениями или с выражениями {\cf\bfseries let} или
{\cf\bfseries lambda}, привязываются фактически не непосредственно к объектам, определённым в
соответствующих привязках, а к адресам памяти, содержащим эти объекты. Содержимое по этим
адресам впоследствии может быть деструктивно изменено с помощью \textit{присваивания}
\index{assignment}:
%
\begin{scheme}
\bfseries(let ((x 23))
\bfseries  (set! x 42)
\bfseries  x) \ev \textbf{42}%
\end{scheme}

%\newpage

%In this case, the body of the {\cf let} expression consists of two
%expressions which are evaluated sequentially, with the value of the
%final expression becoming the value of the entire {\cf let}
%expression.  The expression {\cf (set! x 42)} is an assignment, saying
%``replace the object in the location referenced by {\cf x} with 42''.
%Thus, the previous value of {\cf x}, 23, is replaced by 42.
В данном случае тело выражения {\cf\bfseries let} состоит из двух вычисляемых последовательно
выражений со значением финального выражения, принимающего значение всего выражения {\cf\bfseries
  let}. Выражение {\cf\bfseries (set! x 42),} является присваиванием, указывающим "заменить объект по
адресу, на который указывает {\cf\bfseries x}, на 42". Таким образом, предыдущее значение
{\cf\bfseries x} - 23 изменяется на 42.

%\section{Derived forms and macros}
\section{Производные формы и макросы}
\label{macrosintrosection}

%Many of the special forms specified in this report
%can be translated into more basic special forms.
%For example, a {\cf let} expression can be translated
%into a procedure call and a {\cf lambda} expression.  The following two
%expressions are equivalent:
Большинство специальных форм, определённых в данной работе, могут быть приведены к более
простым специальным формам. Например, выражение {\cf\bfseries let} может быть приведено к вызову
процедуры и выражению {\cf\bfseries lambda}. Следующие два выражения эквивалентны:
%
\begin{scheme}
\bfseries(let ((x 23)
\bfseries      (y 42))
\bfseries  (+ x y)) \ev \textbf{65}

\bfseries((lambda (x y) (+ x y)) 23 42) \lev \textbf{65}%
\end{scheme}

%Special forms like {\cf let} expressions are called \textit{derived
%  forms}\index{derived form} because their semantics can be
%derived from that of other kinds of forms by a syntactic
%transformation.  Some procedure definitions are also derived forms.  The
%following two definitions are equivalent:
Специальные формы, такие, как выражения {\cf\bfseries let}, называются \textit{производными
  формами}\index{derived form}, так как их семантика может быть получена из того или иного вида
форм синтаксическим преобразованием. Некоторые определения процедур также являются производными
формами. Следующие два определения эквивалентны:

\begin{scheme}
\bfseries(define (f x)
\bfseries  (+ x 42))

\bfseries(define f
\bfseries  (lambda (x)
\bfseries    (+ x 42)))%
\end{scheme}

%In Scheme, it is possible for a program to create its own derived
%forms by binding syntactic keywords to macros\index{macro}:
В программе Scheme имеется возможность создания своих собственных производных форм путём связывания
синтаксических ключевых слов с макросами \index{macro}:

\begin{scheme}
\bfseries(define-syntax def
\bfseries  (syntax-rules ()
\bfseries    ((def f (p ...) body)
\bfseries     (define (f p ...)
\bfseries       body))))

\bfseries(def f (x)
\bfseries  (+ x 42))%
\end{scheme}

%The {\cf define-syntax} construct specifies that a parenthesized
%structure matching the pattern {\cf (def f (p ...) body)}, where {\cf
%  f}, {\cf p}, and {\cf body} are pattern variables, is translated to
%{\cf (define (f p ...) body)}.  Thus, the {\cf def} form appearing in
%the example gets translated to:
Конструкция {\cf\bfseries define-syntax} определяет, что заключенная в скобки структура,
соответствующая шаблону {\cf\bfseries (def f (p ...) body)}, где {\cf\bfseries f}, {\cf\bfseries
  p} и {\cf\bfseries body} - переменные шаблона, приводится к {\cf\bfseries (define (f p ...)
  body)}. Таким образом, форма {\cf\bfseries def}, находящаяся в примере, приводится к:

\begin{scheme}
\bfseries(define (f x)
\bfseries  (+ x 42))%
\end{scheme}

%The ability to create new syntactic keywords makes Scheme extremely
%flexible and expressive, allowing many of the features
%built into other languages to be derived forms in Scheme.
Возможность создания новых синтаксических ключевых слов делает Scheme чрезвычайно гибким и
выразительным, что позволяет большинству особенностей, встроенных в другие языки, быть
производными формами в Scheme.

%\section{Syntactic data and datum values}
\section{Синтаксические данные и значения datum}

%A subset of the Scheme objects is called \textit{datum
%  values}\index{datum value}.
%These include booleans, number objects, characters, symbols,
%and strings as well as lists and vectors whose elements are data.  Each
%datum value may be represented in textual form as a
%\textit{syntactic datum}\index{syntactic datum}, which can be written out
%and read back in without loss of information.
%A datum value may be represented by several different syntactic data.
%Moreover, each datum value
%can be trivially translated to a literal expression in a program by
%prepending a {\cf\singlequote} to a corresponding syntactic datum:
Подмножество объектов Scheme называется \textit{значениями datum}\index{datum value}.
Оно включает булевы, численные объекты, знаки, символы и строки, равно как списки и векторы,
элементы которых являются данными. Каждое значение datum может быть представлено в текстовом
виде как \textit{синтаксический datum}\index{syntactic datum}, который может записываться и
считываться без потери информации. Значение datum может быть представлено различными
синтаксическими данными. Кроме того, каждое базисное значение может быть тривиально приведено к
литеральному выражению в программе путём добавления {\cf\singlequote} к соответствующему
синтаксическому datum:

\begin{scheme}
\bfseries'23 \ev \textbf{23}
\bfseries'\schtrue{} \ev \bfseries\schtrue{}
\bfseries'foo \ev \textbf{foo}
\bfseries'(1 2 3) \ev \textbf{(1 2 3)}
\bfseries'\#(1 2 3) \ev \textbf{\#(1 2 3)}%
\end{scheme}

%The {\cf\singlequote} shown in the previous examples
%is not needed for representations of number objects or booleans.
%The syntactic datum {\cf foo} represents a
%symbol with name ``foo'', and {\cf 'foo} is a literal expression with
%that symbol as its value.  {\cf (1 2 3)} is a syntactic datum that
%represents a list with elements 1, 2, and 3, and {\cf '(1 2 3)} is a literal
%expression with this list as its value.  Likewise, {\cf \#(1 2 3)}
%is a syntactic datum that represents a vector with elements 1, 2 and 3, and
%{\cf '\#(1 2 3)} is the corresponding literal.
{\cf\singlequote}, показанный в предыдущих примерах, не нужен для представлений численных
объектов или булевых переменных. Синтаксический базис {\cf\bfseries foo} представляет символ с
именем ``foo'', а {\cf\bfseries 'foo} - литеральное выражение с этим символом в качестве его
значения. {\cf\bfseries (1 2 3)} - синтаксический базис, представляющий список с
элементами 1, 2 и 3, а {\cf\bfseries '(1 2 3)} - литеральное выражение с этим списком в качестве
его значения. Аналогично, {\cf\bfseries \#(1 2 3)} - синтаксический базис, представляющий
вектор с элементами 1, 2 и 3, а {\cf\bfseries '\#(1 2 3)} - соответствующий литерал.


%The syntactic data are a superset of the Scheme forms.  Thus, data
%can be used to represent Scheme forms as data objects.  In
%particular, symbols can be used to represent identifiers.
Синтаксические данные являются расширенным набором форм Scheme. Таким образом, данные могут
использоваться, для представления форм Scheme в виде объектов данных. В частности, символы могут
использоваться для представления идентификаторов.

\begin{scheme}
\bfseries'(+ 23 42) \ev \bfseries(+ 23 42)
\bfseries'(define (f x) (+ x 42)) \lev \bfseries(define (f x) (+ x 42))%
\end{scheme}

%This facilitates writing programs that operate on Scheme source code,
%in particular interpreters and program transformers.
Это облегчает написание программ, работающих с исходным кодом Scheme, в частности,
интерпретаторов и программных преобразователей.\vspace{-2mm}

%\section{Continuations}
\section{Продолжения}

%Whenever a Scheme expression is evaluated there is a
%\textit{continuation}\index{continuation} wanting the result of the
%expression.  The continuation represents an entire (default) future
%for the computation.  For example, informally the continuation of {\cf 3}
%in the expression
Всякий раз, когда выражение Scheme оценено есть \textit{продолжение}\index{continuation}, ожидая
результат выражения. Продолжение представляет все будущее (по умолчанию) для
вычисления. Например, произвольно, продолжение {\cf\bfseries 3} в выражении
%
\begin{scheme}
\bfseries(+ 1 3)%
\end{scheme}
%
%adds 1 to it.  Normally these ubiquitous continuations are hidden
%behind the scenes and programmers do not think much about them.  On
%rare occasions, however, a programmer may need to deal with
%continuations explicitly.  The {\cf call-with-current-continuation}
%procedure (see section~\ref{call-with-current-continuation}) allows
%Scheme programmers to do that by creating a procedure that reinstates
%the current continuation.  The {\cf call-with-current-continuation}
%procedure accepts a procedure, calls it immediately with an argument
%that is an \textit{escape procedure}\index{escape procedure}.  This
%escape procedure can then be called with an argument that becomes the
%result of the call to {\cf call-with-current-continuation}.  That is,
%the escape procedure abandons its own continuation, and reinstates the
%continuation of the call to {\cf call-with-current-continuation}.
добавляет 1 к нему. Обычно эти встречающиеся повсюду продолжения скрыты на заднем плане, и
программисты особо не заботятся о них. В редких случаях, однако, программист, возможно, должен
иметь дело с продолжениями явно. Процедура {\cf\bfseries call-with-current-continuation}
(см. секцию ~\ref{call-with-current-continuation}) позволяет программистам Scheme делать это,
создавая процедуру, которая восстанавливает текущее продолжение. Процедура {\cf\bfseries
  call-with-current-continuation} принимает процедуру, вызывает её немедленно с аргументом,
который является \textit{аварийной процедурой}\index{escape procedure}. Эту аварийную процедуру
можно тогда вызвать с аргументом, который становится результатом вызова {\cf\bfseries
  call-with-current-continuation}. Таким образом, аварийная процедура оставляет ее собственное
продолжение, и восстанавливает продолжение вызова к {\cf\bfseries call-with-current-continuation}.

%In the following example, an escape procedure representing the
%continuation that adds 1 to its argument is bound to {\cf escape}, and
%then called with 3 as an argument.  The continuation of the call to
%{\cf escape} is abandoned, and instead the 3 is passed to the
%continuation that adds 1:
В следующем примере, аварийная процедура, представляющая продолжение, которое добавляет 1 к его
аргументу, привязана к {\cf\bfseries escape}, и затем вызывается с 3 как аргумент. Продолжение
вызова {\cf\bfseries escape} оставлено, и вместо этого эти 3 передают к продолжению, которое добавляет
1:
%
\begin{scheme}
\bfseries(+ 1 (call-with-current-continuation
\bfseries       (lambda (escape)
\bfseries         (+ 2 (escape 3))))) \lev \bfseries 4%
\end{scheme}
%
%An escape procedure has unlimited extent: It can be called after the
%continuation it captured has been invoked, and it can be called
%multiple times.  This makes {\cf call-with-current-continuation}
%significantly more powerful than typical non-local control constructs
%such as exceptions in other languages.
Аварийная процедура имеет неограниченный экстент: Она может быть вызвана после вызова
захватившего его продолжения, и это можно вызвать несколько раз. Это делает {\cf\bfseries
  call-with-current-continuation} значительно более мощным чем типичные нелокальные управляющие
конструкции, типа исключений в других языках.

%\section{Libraries}
\section{Библиотеки}
\label{librariesintrosection}

%Scheme code can be organized in components called
%\textit{libraries}\index{library}.  Each library contains
%definitions and expressions.  It can import definitions
%from other libraries and export definitions to other libraries.
Код Scheme может быть организован в компонентах, которые называются
\textit{библиотеками}\index{library}. Каждая библиотека содержит определения и выражения. Она
может импортировать определения из других библиотек и экспортировать определения в другие
библиотеки.

%The following library called {\cf (hello)} exports a definition called
%{\cf hello-world},  and imports the base library (see
%chapter~\ref{baselibrarychapter}) and the simple I/O library (see
%library section~\extref{lib:simpleiosection}{Simple I/O}).  The {\cf
%  hello-world} export is a procedure that displays {\cf Hello World}
%on a separate line:
Следующая библиотека называется {\cf\bfseries (hello)}, экспортирует определение, которое
называется {\cf\bfseries hello-world}, и импортирует основную библиотеку (см. главу
~\ref{baselibrarychapter}), и простая библиотека I/O (см. библиотечную
секцию~\extref{lib:simpleiosection} {Простой ввод/вывод}). Экспорт {\cf\bfseries hello-world} является
процедурой, которая показывает {\cf\bfseries Hello World} на отдельной линии:
%
\begin{scheme}
\bfseries(library (hello)
\bfseries  (export hello-world)
\bfseries  (import (rnrs base)
\bfseries          (rnrs io simple))
\bfseries  (define (hello-world)
\bfseries    (display "Hello World")
\bfseries    (newline)))%
\end{scheme}

%\section{Top-level programs}
\section{Программы верхнего уровня}

%A Scheme program is invoked via a \textit{top-level
%  program}\index{top-level program}.  Like a library, a top-level
%program contains imports, definitions and expressions, and specifies
%an entry point for execution.  Thus a top-level program defines, via
%the transitive closure of the libraries it imports, a Scheme program.
Программа Scheme активизируется посредством \textit{программы верхнего уровня}\index{top-level
  program}. Как и библиотека, программа верхнего уровня содержит импорт, определения и
выражения, и определяет точку входа для выполнения. Таким образом, программа верхнего уровня
определяет, через замкнутое выражение библиотек, которые это импортирует, программу Scheme.

%The following top-level program obtains the first argument from the command line
%via the {\cf command-line} procedure from the \rsixlibrary{programs}
%library (see library chapter~\extref{lib:programlibchapter}{Command-line
%  access and exit values}).  It then opens the file using {\cf
%  open-file-input-port} (see library section~\extref{lib:portsiosection}),
%yielding a \textit{port}, i.e.\ a connection to the file as a data
%source, and calls the {\cf get-bytes-all} procedure to obtain the
%contents of the file as binary data.  It then uses {\cf put-bytes} to
%output the contents of the file to standard output:
Следующая программа верхнего уровня получает первый аргумент из командной строки через процедуру
{\cf\bfseries command-line} из библиотеки {\bfseries\rsixlibrary{programs}} (см. библиотечную
главу~\extref{lib:programlibchapter}{Доступ к командной строке и выходные значения}). Это тогда
открывает файл с помощью {\cf\bfseries open-file-input-port} (см. секцию
~\extref{lib:portsiosection}), приводя к \textit{порт}, т.е.\ к связи с файлом как источником
данных, и вызывает процедуру {\cf\bfseries get-bytes-all} получения содержимого файла в виде
двоичных данных. Это тогда использует {\cf\bfseries put-bytes} для вывода содержимого файла в
стандартный вывод:\vspace{3mm}
%
\begin{scheme}
\bfseries\#!r6rs
\bfseries(import (rnrs base)
\bfseries        (rnrs io ports)
\bfseries        (rnrs programs))
\bfseries(put-bytes (standard-output-port)
\bfseries           (call-with-port
\bfseries               (open-file-input-port
\bfseries                 (cadr (command-line)))
\bfseries             get-bytes-all))%
\end{scheme}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End:
