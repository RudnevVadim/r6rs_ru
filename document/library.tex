%\chapter{Libraries}
\chapter{Библиотеки}\vspace{2mm}
\label{librarychapter}
\mainindex{library}

%Libraries are parts of a program that can be distributed
%independently.
%The library system supports macro definitions within libraries,
%macro exports, and distinguishes the phases in which definitions
%and imports are needed.  This chapter defines the notation for
%libraries and a semantics for library expansion and execution.
Библиотеки являются частями программы, которые могут поставляться независимо. Система библиотек
поддерживает макроопределения внутри библиотек, макроэкспорт, а также различает требуемые фазы
определений и импортирований. В данной главе описана нотация библиотек и семантика расширения
и реализации библиотек.

%\section{Library form}
\section{Библиотечная форма}
\label{librarysyntaxsection}

%A library definition must have the following form:\mainschindex{library}\mainschindex{import}\mainschindex{export}
Определение библиотеки имеет следующую форму:\mainschindex{library}\mainschindex{import}\mainschindex{export}

\begin{scheme}
\textbf{(library} \hyper{library~name}
  \textbf{(export} \hyper{export~spec} \ldots\textbf{)}
  \textbf{(import} \hyper{import~spec} \ldots\textbf{)}
  \hyper{library~body}\textbf{)}%
\end{scheme}

%A library declaration contains the following elements:
Объявление библиотеки содержит следующие элементы:

\begin{itemize}
%\item The \hyper{library~name} specifies the name of the library
%  (possibly with version).
\item \hyper{library~name} указывает имя библиотеки (возможно с версией).
%\item The {\cf export} subform specifies a list of exports, which name
%  a subset of the bindings defined within or imported into the
%  library.
\item Подформа {\cf\bfseries export} указывает экспортируемый список, именующий подмножество
  привязок, определённых внутри или импортированных в библиотеку.
%\item The {\cf import} subform specifies the imported bindings as a
%  list of import dependencies, where each dependency specifies:
\item Подформа {\cf\bfseries import} указывает импортируемые привязки в виде списка
  импортируемых зависимостей, где каждая зависимость указывает:
\begin{itemize}
%\item the imported library's name, and, optionally, constraints on its
%  version,
\item имя импортируемой библиотеки и, при необходимости, ограничения её версии,
%\item the relevant levels, e.g., expand or run time (see
%  section~\ref{phasessection}, and
\item релевантные уровни, например, этап разворачивания или выполнения (см
  секцию~\ref{phasessection}, и
%\item the subset of the library's exports to make available within the
%      importing library, and the local names to use within the importing
%      library for each of the library's exports.
\item подмножество библиотечных элементов экспорта для обеспечения доступности внутри
  импортирующей библиотеки, а также локальные имена, используемые внутри импортирующей
  библиотеки вместо каждого библиотечного элемента экспорта.
\end{itemize}
%\item The \hyper{library body} is the library body, consisting of a
%  sequence of definitions followed by a sequence of expressions.  The
%  definitions may be both for local (unexported) and exported
%  bindings, and the expressions are initialization expressions to be evaluated
%  for their effects.
\item \hyper{library body} - тело библиотеки, состоящее из последовательности определений
  и следующей за ней последовательности выражений. Определения могут применяться как для локальных
  (неэкспортируемых), так и для экспортируемых привязок, а выражения являются
  инициализирующими выражениями, вычисляемыми ради их эффектов.
\end{itemize}\vspace{-1mm}

%An identifier can be imported with the same local name from two or
%more libraries or for two levels from the same library only if the
%binding exported by each library is the same (i.e., the binding is
%defined in one library, and it arrives through the imports only by
%exporting and re-exporting).  Otherwise, no identifier can be imported
%multiple times, defined multiple times, or both defined and imported.
%No identifiers are visible within a library except for those
%explicitly imported into the library or defined within the library.
Идентификатор может импортироваться с одним локальным именем из двух или более библиотек или для
двух уровней из одной библиотеки только в случае, если экспортируемые каждой библиотекой
привязки тождественны (то есть, если привязка определена в одной библиотеке и поступает
посредством импортирования, будучи только экспортированной и реэкспортированной). В противном
случае идентификатор не может быть импортирован несколько раз, определён несколько раз, или
определён и импортирован. Идентификаторы невидимы внутри библиотеки, за исключением явно
импортированных в неё или определённых внутри неё.

%A \hyper{library name} uniquely identifies a library within an
%implementation, and is globally visible in the {\cf import} clauses
%(see below) of all other libraries within an implementation.
%A \hyper{library name} has the following form:
\hyper{library name} однозначно идентифицирует библиотеку внутри реализации и является глобально
видимым в разделах {\cf\bfseries import} (см. ниже) всех других библиотек внутри
реализации. \hyper{library name} имеет следующую форму:

\begin{scheme}
\textbf{(}\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version}\textbf{)}%
\end{scheme}

%where \hyper{version} is empty or has the following form:
где \hyper{version} отсутствует или имеет следующую форму:
%
\begin{scheme}
\textbf{(}\hyper{sub-version} \ldots\textbf{)}%
\end{scheme}

%Each \hyper{sub-version} must represent an exact nonnegative integer object.
%An empty \hyper{version} is equivalent to {\cf ()}.
Каждая \hyper{sub-version} должна представлять точный неотрицательный целый объект.
Отсутствие \hyper{version} эквивалентно {\cf\bfseries ()}.

%An \hyper{export~spec} names a set of imported and locally defined bindings to
%be exported, possibly with different
%external names.  An \hyper{export~spec} must have one of the
%following forms:
\hyper{export~spec} именует совокупность импортированных и локально определённых для
экспортирования привязок, возможно с другими внешними именами. \hyper{export~spec} должна иметь
одну из следующих форм:

\begin{scheme}
\hyper{identifier}
\textbf{(rename} (\hyperi{identifier} \hyperii{identifier}) \ldots\textbf{)}%
\end{scheme}

%In an \hyper{export~spec}, an \hyper{identifier} names a single binding defined
%within or imported into the library, where the external name for the export is
%the same as the name of the binding within the library.
%A {\cf rename} spec exports the binding named by
%\hyperi{identifier} in each {\cf (\hyperi{identifier}
%  \hyperii{identifier})} pairing, using \hyperii{identifier} as the
%external name.
\hyper{identifier} в \hyper{export~spec} именует одиночную привязку, определённую внутри или
импортированную в библиотеку, причём внешнее экспортируемое имя совпадает с именем привязки внутри
библиотеки. Спецификация {\cf\bfseries rename} экспортирует привязку с именем
\hyperi{identifier} в каждой паре {\cf (\hyperi{identifier} \hyperii{identifier})},
используя \hyperii{identifier} в качестве внешнего имени.

%Each \hyper{import~spec} specifies a set of bindings to be imported into
%the library, the levels at which they are to be available, and the local
%names by which they are to be known.  An \hyper{import spec} must
%be one of the following:
Каждая \hyper{import~spec} специфицирует множество привязок, импортируемых в
библиотеку, уровни, на которых они должны быть доступны и локальные имена, которыми
они должны быть названы. \hyper{import spec} должна быть одной из следующих форм:

%\newpage

\begin{scheme}
\hyper{import set}
\textbf{(for} \hyper{import~set} \hyper{import~level} \ldots\bfseries{)}%
\end{scheme}\vspace{1mm}

%An \hyper{import level}  is one of the following:
\hyper{import level} является одним из следующих элементов:\vspace{1mm}
\begin{scheme}
\textbf{run}
\textbf{expand}
\textbf{(meta} \hyper{level}\textbf{)}%
\end{scheme}\vspace{1mm}

%where \hyper{level} represents an exact integer object.
где \hyper{level} представляет собой точный целый объект.\vspace{1mm}

%As an \hyper{import level}, {\cf run} is an abbreviation for {\cf
%  (meta 0)}, and {\cf expand} is an abbreviation for {\cf (meta 1)}.
%Levels and phases are discussed in section~\ref{phasessection}.
{\cf \bfseries run} в форме \hyper{import level} является сокращением для {\cf\bfseries (meta
  0)}, а {\cf\bfseries expand} -- сокращением для {\cf\bfseries (meta 1)}. Уровни и фазы описаны
в секции~\ref{phasessection}.\vspace{1mm}

%An \hyper{import~set} names a set of bindings from another library and
%possibly specifies local names for the imported bindings.  It must be
%one of the following:
\hyper{import~set} именует множество привязок из другой библиотеки и, возможно, определяет
локальные имена для импортированных привязок. Он должен быть одной из следующих форм:\vspace{1mm}

\begin{scheme}
\hyper{library~reference}
\textbf{(library} \hyper{library~reference}\textbf{)}
\textbf{(only} \hyper{import~set} \hyper{identifier} \ldots\textbf{)}
\textbf{(except} \hyper{import~set} \hyper{identifier} \ldots\textbf{)}
\textbf{(prefix} \hyper{import~set} \hyper{identifier}\textbf{)}
\textbf{(rename} \hyper{import~set} \textbf{(}\hyperi{identifier} \hyperii{identifier}\textbf{)} \ldots\textbf{)}%
\end{scheme}\vspace{1mm}

%A \hyper{library~reference} identifies a library by its
%name and optionally by its version.  It has one of the following forms:
\hyper{library~reference} идентифицирует библиотеку её именем и,
необязательно, её версией. Оно имеет одну из следующих форм:\vspace{1mm}

\begin{scheme}
\textbf{(}\hyperi{identifier} \hyperii{identifier} \ldots\textbf{)}
\textbf{(}\hyperi{identifier} \hyperii{identifier} \ldots \hyper{version~reference}\textbf{)}%
\end{scheme}\vspace{1mm}

%A \hyper{library~reference} whose first \hyper{identifier} is
%{\cf for}, {\cf library}, {\cf only}, {\cf except}, {\cf prefix}, or {\cf rename} is
%permitted only within a {\cf library} \hyper{import~set}.
%The \hyper{import~set} {\cf (library \hyper{library~reference})} is
%otherwise equivalent to \hyper{library~reference}.
\hyper{library~reference}, первым \hyper{identifier} которого является {\cf\bfseries for}, {\cf\bfseries
library}, {\cf\bfseries only}, {\cf\bfseries except}, {\cf\bfseries prefix} или {\cf\bfseries
rename}, разрешается только внутри {\cf\bfseries library}
\hyper{import~set}. \hyper{import~set} {\cf\textbf{(library}
  \hyper{library~reference}\textbf{)}} в противном случае
эквивалентен \hyper{library~reference}.\vspace{1mm}

%A \hyper{library~reference} with no \hyper{version~reference}
%(first form above) is equivalent to a \hyper{library~reference} with a
%\hyper{version~reference} of {\cf ()}.
\hyper{library~reference} без \hyper{version~reference} (первая форма выше) эквивалентно
\hyper{library~reference} с \hyper{version~reference} -- {\cf\bfseries ()}.\vspace{1mm}

%A \hyper{version~reference} specifies a set of \hyper{version}s that
%it matches.  The \hyper{library~reference} identifies all libraries of
%the same name and whose version is matched by the
%\hyper{version~reference}.  A \hyper{version~reference} has
%the following form:
\hyper{version~reference} специфицирует множество соответствующих ему \hyper{version}.
\hyper{library~reference} идентифицирует все одноименные библиотеки,
версия которых соответствует \hyper{version~reference}. \hyper{version~reference}
имеет следующую форму:\vspace{1mm}
%
\begin{scheme}
\textbf{(}\hyperi{sub-version reference} \ldots \hypern{sub-version reference}\textbf{)}
\textbf{(and} \hyper{version reference} \ldots\textbf{)}
\textbf{(or} \hyper{version reference} \ldots\textbf{)}
\textbf{(not} \hyper{version reference}\textbf{)}%
\end{scheme}\vspace{1mm}
%
%A \hyper{version reference} of the first form matches a \hyper{version}
%with at least $n$ elements, whose \hyper{sub-version reference}s match
%the corresponding \hyper{sub-version}s.  An {\cf and} \hyper{version
%  reference} matches a version if all \hyper{version references}
%following the {\cf and} match it.  Correspondingly, an {\cf
%  or} \hyper{version reference} matches a version if one of
%\hyper{version references} following the {\cf or} matches it,
%and a {\cf not} \hyper{version reference} matches a version if the
%\hyper{version reference} following it does not match it.
\hyper{version reference} первой формы соответствует \hyper{version} с не менее $n$
элементами, \hyper{sub-version reference} которого совпадает с
соответствующими \hyper{sub-version}. {\cf\bfseries and} \hyper{version reference} соответствует
версии, если все \hyper{version references} после {\cf\bfseries and} соответствуют
ей. Соответственно, {\cf\bfseries or} \hyper{version reference} соответствует версии, если
один из \hyper{version references} после {\cf\bfseries or} соответствуют ей, и {\cf\bfseries
  not} \hyper{version reference} соответствует версии, если \hyper{version references} после
него не соответствует ей.\vspace{1mm}

%A \hyper{sub-version reference} has one of the following forms:
\hyper{sub-version reference} имеет одну из следующих форм:

%\newpage

\begin{scheme}
\hyper{sub-version}
\textbf{(>=} \hyper{sub-version}\textbf{)}
\textbf{(<=} \hyper{sub-version}\textbf{)}
\textbf{(and} \hyper{sub-version~reference} \ldots\textbf{)}
\textbf{(or} \hyper{sub-version~reference} \ldots\textbf{)}
\textbf{(not} \hyper{sub-version~reference}\textbf{)}%
\end{scheme}\vspace{1mm}

%A \hyper{sub-version reference} of the first form matches a
%\hyper{sub-version} if it is equal to it.  A {\cf >=}
%\hyper{sub-version reference} of the first form matches a sub-version
%if it is greater or equal to the \hyper{sub-version} following it;
%analogously for {\cf <=}.  An {\cf and} \hyper{sub-version reference}
%matches a sub-version if all of the subsequent \hyper{sub-version
%  reference}s match it.  Correspondingly, an {\cf or}
%\hyper{sub-version reference} matches a sub-version if one of the
%subsequent \hyper{sub-version reference}s matches it, and a {\cf not}
%\hyper{sub-version reference} matches a sub-version if the subsequent
%\hyper{sub-version reference} does not match it.
\hyper{sub-version reference} первой формы соответствует \hyper{sub-version}, если они равны.
{\cf\bfseries >=} \hyper{sub-version reference} второй формы соответствует sub-version, если оно
больше или равно \hyper{sub-version} после него; для {\cf\bfseries
  <=} -- аналогично. {\cf\bfseries and} \hyper{sub-version reference} соответствует sub-version, если все
последующие \hyper{sub-version reference} соответствуют ему. Соответственно, {\cf\bfseries or}
\hyper{sub-version reference} соответствует sub-version, если один из последующих \hyper{sub-version
reference} соответствует ему, и {\cf\bfseries not} \hyper{sub-version reference} соответствует
\hyper{sub-version}, если последующий \hyper{sub-version reference} не соответствует ему.\vspace{1mm}

%Examples:
Примеры:\vspace{1mm}

\texonly\begin{center}\endtexonly
  \begin{tabular}{lll}
    version reference & version & match?
    \\
    {\cf\bfseries ()} & {\cf\bfseries (1)} & yes\\
    {\cf\bfseries (1)} & {\cf\bfseries (1)} & yes\\
    {\cf\bfseries (1)} & {\cf\bfseries (2)} & no\\
    {\cf\bfseries (2 3)} & {\cf\bfseries (2)} & no\\
    {\cf\bfseries (2 3)} & {\cf\bfseries (2 3)} & yes\\
    {\cf\bfseries (2 3)} & {\cf\bfseries (2 3 5)} & yes\\
    {\cf\bfseries (or (1 (>= 1)) (2))} & {\cf\bfseries (2)} & yes\\
    {\cf\bfseries (or (1 (>= 1)) (2))} & {\cf\bfseries (1 1)} & yes\\
    {\cf\bfseries (or (1 (>= 1)) (2))} & {\cf\bfseries (1 0)} & no\\
    {\cf\bfseries ((or 1 2 3))} & {\cf\bfseries (1)} & yes\\
    {\cf\bfseries ((or 1 2 3))} & {\cf\bfseries (2)} & yes\\
    {\cf\bfseries ((or 1 2 3))} & {\cf\bfseries (3)} & yes\\
    {\cf\bfseries ((or 1 2 3))} & {\cf\bfseries (4)} & no
  \end{tabular}\vspace{1mm}
\texonly\end{center}\endtexonly

%When more than one library is identified by a library reference, the
%choice of libraries is determined in some implementation-dependent manner.
Если при обращении к библиотеке идентифицировано более одной библиотеки, выбор библиотеки
определяется неким зависимым от реализации методом.\vspace{1mm}

%To avoid problems such as incompatible types and replicated state,
%implementations should prohibit the two libraries whose library names
%consist of the same sequence of identifiers but whose versions do not
%match to co-exist in the same program.
Во избежании проблем, таких, как несовместимость типов и дублирование состояний, реализация
должна запретить сосуществование в одной программе двух библиотек, библиотечные имена которых
состоят из одинаковой последовательности идентификаторов, но версии которых являются
несоответствующими.\vspace{1mm}

%By default, all of an imported library's exported bindings are made
%visible within an importing library using the names given to the bindings
%by the imported library.
%The precise set of bindings to be imported and the names of those
%bindings can be adjusted with the {\cf only}, {\cf except},
%{\cf prefix}, and {\cf rename} forms as described below.
По умолчанию все экспортируемые привязки импортируемой библиотеки предполагаются видимыми
внутри импортирующей библиотеки с именами, присвоенными привязкам в импортируемой
библиотеке. Точный набор импортитуемых привязок и имён этих привязок может быть установлен с
помощью форм {\cf\bfseries only}, {\cf\bfseries except}, {\cf\bfseries prefix} и {\cf\bfseries
rename}, как описано ниже.\vspace{1mm}

\begin{itemize}
%\item An {\cf only} form produces a subset of the bindings from another
%\hyper{import~set}, including only the listed
%\hyper{identifier}s.
%The included \hyper{identifier}s must be in
%the original \hyper{import~set}.
\item Форма {\cf\bfseries only} порождает подмножество привязок из другого \hyper{import~set},
  содержащее только перечисленные \hyper{identifier}. Включённые \hyper{identifier} должны
  существовать в исходном \hyper{import~set}.
%\newpage
%\item An {\cf except} form produces a subset of the bindings from another
%\hyper{import~set}, including all but the listed
%\hyper{identifier}s.
%All of the excluded \hyper{identifier}s must be in
%the original \hyper{import~set}.
\item Форма {\cf\bfseries except} порождает подмножество привязок из другого \hyper{import~set},
  содержащее все \hyper{identifier}, кроме перечисленных. Включённые \hyper{identifier} должны
  существовать в исходном \hyper{import~set}.
%\item A {\cf prefix} form adds the \hyper{identifier} prefix to each
%name from another \hyper{import~set}.
\item Форма {\cf\bfseries prefix} добавляет приставку \hyper{identifier} к каждому
  имени из другого \hyper{import~set}.
%\item A {\cf rename} form, {\cf (rename (\hyperi{identifier} \hyperii{identifier}) \ldots)},
%removes the bindings for {\cf \hyperi{identifier} \ldots} to form an
%intermediate \hyper{import~set}, then adds the bindings back for the
%corresponding {\cf \hyperii{identifier} \ldots} to form the final
%\hyper{import~set}.
%Each \hyperi{identifier} must be in the original \hyper{import~set},
%each \hyperii{identifier} must not be in the intermediate \hyper{import~set},
%and the \hyperii{identifier}s must be distinct.
\item Форма {\cf\bfseries rename}, {\cf \textbf{(rename (}\hyperi{identifier}
  \hyperii{identifier}\textbf{)} \ldots\textbf{)}}, удаляет привязки для {\cf
  \hyperi{identifier} \ldots} для формирования промежуточного \hyper{import~set}, затем
  добавляет привязки назад для соответствующего {\cf \hyperii{identifier} \ldots} для
  формирования конечного \hyper{import~set}. Каждый \hyperi{identifier} должен существовать в исходном
  \hyper{import~set}, каждый \hyperii{identifier} не должен существовать в промежуточном
  \hyper{import~set}, а все \hyperii{identifier} должны быть разными.
\end{itemize}\vspace{1mm}
%It is a syntax violation if a constraint given above is not met.
Невыполнение приведённого выше ограничения является синтаксическим нарушением.\vspace{1mm}

\label{librarybodysection}
%The \hyper{library~body} of a {\cf library} form consists of forms
%that are classified as
%\textit{definitions}\mainindex{definition} or
%\textit{expressions}\mainindex{expression}.  Which forms belong to
%which class depends on the imported libraries and the result of
%expansion---see chapter~\ref{expansionchapter}.  Generally, forms that
%are not
%definitions (see section~\ref{defines} for definitions available
%through the base library) are expressions.
\hyper{library~body} формы {\cf\bfseries library} состоит из форм, классифицируемых как
\textit{определения}\mainindex{definition} или
\textit{выражения}\mainindex{expression}. Принадлежность конкретной формы конкретному классу
зависит от импортированных библиотек и результатов
разворачивания---см. главу~\ref{expansionchapter}. В общем случае формы, не являющиеся
определениями (о доступных при использовании базовой
библиотеки определениях см. секцию ~\ref{defines}), являются выражениями.\vspace{1mm}

%A \hyper{library~body} is like a \hyper{body} (see section~\ref{bodiessection}) except that
%a \hyper{library~body}s need not include any expressions.  It must
%have the following form:
\hyper{library~body} аналогично \hyper{body} (см. секцию~\ref{bodiessection}) за исключением
того, что в \hyper{library~body} не обязаны содержаться выражения. Оно должно иметь следующую
форму:\vspace{1mm}

\begin{scheme}
\hyper{definition} \ldots \hyper{expression} \ldots%
\end{scheme}\vspace{1mm}

%When {\cf begin}, {\cf let-syntax}, or {\cf letrec-syntax} forms
%occur in a top-level body prior to the first
%expression, they are spliced into the body; see section~\ref{begin}.
%Some or all of the body, including portions wrapped in {\cf begin},
%{\cf let-syntax}, or {\cf letrec-syntax}
%forms, may be specified by a syntactic abstraction
%(see section~\ref{macrosection}).
Если формы {\cf\bfseries begin}, {\cf\bfseries let-syntax} или {\cf\bfseries letrec-syntax}
находятся в теле верхнего уровня до первого выражения, они встраиваются в тело; см.
секцию ~\ref{begin}. Всё тело или его часть, включая части, обёрнутые в формы {\cf\bfseries begin},
{\cf\bfseries let-syntax} или {\cf\bfseries letrec-syntax}, может быть определено
синтаксической абстракцией (см. секцию~\ref{macrosection}).\vspace{1mm}

%The transformer expressions and bindings are evaluated and created
%from left to right, as described in chapter~\ref{expansionchapter}.
%The expressions of variable definitions are evaluated
%from left to right, as if in an implicit {\cf letrec*},
%and the body expressions are also evaluated from left to right
%after the expressions of the variable definitions.
%A fresh location is created for each exported variable and initialized
%to the value of its local counterpart.
%The effect of returning twice to the continuation of the last body
%expression is unspecified.
Трансформирующие выражения и привязки вычисляются и создаются слева направо, как описано в главе
~\ref{expansionchapter}. Выражения определений переменных вычисляются слева направо, как в
неявном {\cf\bfseries letrec*}, выражения тела также вычисляются слева направо после выражений
определений переменных. Для каждой экспортируемой переменной создаётся новая ячейка и
инициализируется значением её локальной копии. Эффект повторного возвращения к продолжению
последнего выражения тела не определён.\vspace{1mm}

\begin{note}
%The names {\cf library}, {\cf export}, {\cf import},
%{\cf for}, {\cf run}, {\cf expand}, {\cf meta},
%{\cf import}, {\cf export}, {\cf only}, {\cf except}, {\cf
%  prefix}, {\cf rename}, {\cf and}, {\cf or}, {\cf not}, {\cf >=}, and {\cf <=}
%appearing in the library syntax are part of the
%syntax and are not reserved, i.e., the same names can be used for other
%purposes within the library or even exported from or imported
%into a library with different meanings, without affecting their
%use in the {\cf library} form.
Имена {\cf\bfseries library}, {\cf\bfseries export}, {\cf\bfseries import}, {\cf\bfseries for},
{\cf\bfseries run}, {\cf\bfseries expand}, {\cf\bfseries meta}, {\cf\bfseries import},
{\cf\bfseries export}, {\cf\bfseries only}, {\cf\bfseries except}, {\cf\bfseries prefix},
{\cf\bfseries rename}, {\cf\bfseries and}, {\cf\bfseries or}, {\cf\bfseries not}, {\cf\bfseries
  >=} и {\cf\bfseries <=}, входящие в библиотечный синтаксис, являются частью синтаксиса и не
зарезервированы, то есть, эти имена могут использоваться для других целей внутри
библиотеки или даже экспортироваться из библиотеки или импортироваться в библиотеку с другими
значениями, не влияющими на их использование в форме {\cf\bfseries library}.
\end{note}

%Bindings defined with a library are not visible in code
%outside of the library, unless the bindings are explicitly exported from the
%library.
%An exported macro may, however, \emph{implicitly export} an otherwise
%unexported identifier defined within or imported into the library.
%That is, it may insert a reference to that identifier into the output code
%it produces.
Определённые библиотекой привязки невидимы в коде вне библиотеки, если они явно не
экспортированы из библиотеки. Однако экспортированный макрос может \emph{неявно экспортировать}
в иных случаях неэкспортируемый идентификатор, определённый в библиотеке или
импортированный в неё. Иными словами, он может вставить обращение к этому идентификатору
в генерируемый им выходной код.\vspace{-1.2mm}

\label{importsareimmutablesection}
%All explicitly exported variables are immutable in both the
%exporting and importing libraries.
%It is thus a syntax violation if an
%explicitly exported variable appears on the left-hand side of a {\cf set!}
%expression, either in the exporting or importing libraries.
Все явно экспортированные переменные являются неизменяемыми и в экспортируемых, и в импортируемых
библиотеках. Таким образом, наличие явно экспортированной переменной в левой части выражения
{\cf\bfseries set!} является нарушением синтаксиса как в экспортируемых, так и в импортируемых
библиотеках.\vspace{-1.2mm}

%All implicitly exported variables are also immutable in both the
%exporting and importing libraries.
%It is thus a syntax violation if a
%variable appears on the left-hand side of a {\cf set!}
%expression in any code produced by an exported macro outside of the
%library in which the variable is defined.
%It is also a syntax violation if a
%reference to an assigned variable appears in any code produced by
%an exported macro outside of the library in which the variable is defined,
%where an assigned variable is one that appears on the left-hand
%side of a {\cf set!} expression in the exporting library.
Все неявно экспортированные переменные также являются неизменяемыми и в экспортируемых, и в
импортируемых библиотеках. Таким образом, наличие переменной в левой части выражения
{\cf\bfseries set!} любого кода, сгенерированного экспортированным макросом вне библиотеки, в
которой определена переменная, является нарушением синтаксиса. Также является нарушением
синтаксиса наличие обращения к присваиваемой переменной в любом коде, сгенерированном
экспортируемым макросом вне библиотеки, в которой определена переменная, где присваиваемой
переменной является находящаяся в левой части выражения {\cf\bfseries set!} переменная в
экспортируемой библиотеке.\vspace{-1.2mm}

%All other variables defined within a library are mutable.
Все остальные определённые в библиотеке переменные являются изменяемыми.\vspace{-5.4mm}

%\section{Import and export levels}
\section{Уровни экспорта и импорта}\vspace{-3.2mm}
\label{phasessection}

%Expanding a library may require run-time information from another
%library.  For example, if a macro transformer calls a
%procedure from library $A$, then the library $A$ must be
%instantiated before expanding any use of the macro in library $B$.  Library $A$ may
%not be
%needed when library $B$ is eventually run as part of a program, or it
%may be needed for run time of library $B$, too.  The library
%mechanism distinguishes these times by phases, which are explained in
%this section.
При разворачивании библиотеки может потребоваться информация этапа выполнения из другой
библиотеки. Например, при вызове макротрансформером процедуры из библиотеки $A$, библиотека
$A$ должна быть инстанцирована перед разворачиванием любого применения макроса в библиотеке
$B$. Библиотека $A$ в итоге может и не потребоваться при выполнении библиотеки $B$ как части
программы, или же она может потребоваться библиотеке $B$ также и для этапа выполнения.
Механизм библиотек характеризует эти этапы фазами, описываемыми в данной секции.\vspace{-1.2mm}

%Every library can be characterized by expand-time information (minimally,
%its imported libraries, a list of the exported keywords, a list of the
%exported variables, and code to evaluate the transformer expressions) and
%run-time information (minimally, code to evaluate the variable definition
%right-hand-side expressions, and code to evaluate the body expressions).
%The expand-time information must be available to expand references to
%any exported binding, and the run-time information must be available to
%evaluate references to any exported variable binding.
Каждая библиотека может характеризоваться информацией этапа разворачивания (как минимум, её
импортированные библиотеки, список экспортируемых ключевых слов, список экспортируемых
переменных и код вычисления преобразовательных выражений) и информацией этапа выполнения
(как минимум, код вычисления выражений правой части определений переменных и код
вычисления выражений тела). Информация этапа разворачивания должна быть доступна для разворачивания
обращений к каким-либо экспортированным привязкам, а информация этапа выполнения -
для вычисления обращений к каким-либо экспортированным привязкам переменных.\vspace{-1.2mm}

\mainindex{phase}
%
%A \emph{phase} is a time at which the expressions within a library are
%evaluated.
%Within a library body, top-level expressions and
%the right-hand sides of {\cf define} forms are evaluated at run time,
%i.e., phase $0$, and the right-hand
%sides of {\cf define-syntax} forms are evaluated at expand time, i.e.,
%phase $1$.
%When {\cf define-syntax},
%{\cf let-syntax}, or {\cf letrec-syntax}
%forms appear within code evaluated at phase $n$, the right-hand sides
%are evaluated at phase $n+1$.
\emph{Фаза} -- это этап, в течение которого вычисляются выражения в библиотеке. Внутри тела
библиотеки выражения верхнего уровня и правые части форм {\cf\bfseries define} вычисляются на
этапе выполнения, то есть, в фазе $0$, а правые части форм {\cf\bfseries define-syntax} -- на этапе
разворачивания, то есть, в фазе $1$. Если формы {\cf\bfseries define-syntax}, {\cf\bfseries
  let-syntax} или {\cf\bfseries letrec-syntax} находятся внутри кода, вычисляемого в фазе $n$,
правые части вычисляются в фазе $n+1$.

%\newpage

%These phases are relative to the phase in which the library itself is
%used.
%An \defining{instance} of a library corresponds to an evaluation of its
%variable definitions and expressions in a particular phase relative to another
%library---a process called \defining{instantiation}.
%For example, if a top-level expression in a library $B$ refers to
%a variable export from another library $A$, then it refers to the export from an
%instance of $A$ at phase $0$ (relative to the phase of $B$).
%But if a phase $1$ expression within $B$ refers to the same binding from
%$A$, then it refers to the export from an instance of $A$ at phase $1$
%(relative to the phase of $B$).
Эти фазы связаны с фазой, в которой используется сама библиотека. \defining{Экземпляр}
библиотеки соответствует вычислению её определений переменных и выражений в конкретной фазе
относительно другой библиотеки---процессу, называемому \defining{инстанцированием}. Например,
если выражение верхнего уровня библиотеки $B$ обращается к переменной, экспортируемой из
другой библиотеки $A$, то оно обращается к экспорту из экземпляра $A$ в фазе $0$ (относительно
фазы $B$). Но если выражение фазы $1$ внутри $B$ обращается к тому же связыванию из
$A$, то оно обращается к экспорту из экземпляра $A$ в фазе $1$ (относительно фазы $B$).

%A \defining{visit} of a library corresponds to the evaluation of its syntax
%definitions in a particular phase relative to another
%library---a process called \defining{visiting}.
%For example, if a top-level expression in a library $B$ refers to
%a macro export from another library $A$, then it refers to the export from a
%visit of $A$ at phase $0$ (relative to the phase of $B$), which corresponds
%to the evaluation of the macro's transformer expression at phase $1$.
\defining{Посещение} библиотеки соответствует вычислению её определений синтаксиса
в конкретной фазе относительно другой библиотеки---процессу, называемому \defining
{посещением}. Например, если выражение верхнего уровня библиотеки $B$ обращается к
макроэкспорту из другой библиотеки $A$, то оно обращается к экспорту из посещения
$A$ в фазе $0$ (относительно фазы $B$), которая соответствует вычислению выражения
макротрансформера в фазе $1$.

\mainindex{level}\mainindex{import level}
%
%A \emph{level} is a lexical property of an identifier that determines
%in which phases it can be referenced. The level for each identifier
%bound by a definition within a library is $0$; that is, the identifier
%can be referenced only at phase $0$ within the library.
%The level for each imported binding is determined by the enclosing {\cf
%  for} form of the {\cf import} in the importing library, in
%addition to the levels of the identifier in the exporting
%library. Import and export levels are combined by pairwise addition of
%all level combinations.  For example, references to an imported
%identifier exported for levels $p_a$ and $p_b$ and imported for levels
%$q_a$, $q_b$, and $q_c$ are valid at levels $p_a+q_a$, $p_a+q_b$,
%$p_a+q_c$, $p_b+q_a$, $p_b+q_b$, and $p_b+q_c$. An \hyper{import~set}
%without an enclosing {\cf for} is equivalent to {\cf (for
%  \hyper{import~set} run)}, which is the same as {\cf (for
%  \hyper{import~set} (meta 0))}.
\emph{Уровень} -- это лексическое свойство идентификатора, определяющее, в каких фазах
допускаются обращения к нему. Уровнем каждого идентификатора, привязанного определением внутри
библиотеки, является $0$; то есть, внутри библиотеки к идентификатору допускается обращение
только в фазе $0$. Уровень каждой импортированной привязки определяется не только уровнями
идентификаторов в экспортируемой библиотеке, но и ограничивающей формой {\cf\bfseries for} формы
{\cf\bfseries import} в импортируемой библиотеке. Уровни импорта и экспорта объединяются попарным
суммированием всех комбинаций уровней. Например, обращения к импортируемому идентификатору,
экспортируемому для уровней $p_a$ и $p_b$ и импортированному для уровней $q_a$, $q_b$, и $q_c$,
применимы на уровнях $p_a+q_a$, $p_a+q_b$, $p_a+q_c$, $p_b+q_a$, $p_b+q_b$ и
$p_b+q_c$. \hyper{import~set} без ограничивающего {\cf\bfseries for} эквивалентен {\cf \textbf{(for}
  \hyper {import~set} \textbf{run)}}, что тождественно {\cf \textbf{(for}
  \hyper{import~set} \bfseries(meta 0))}.

%The export level of an exported binding is $0$ for all bindings
%that are defined within the exporting library. The export levels of a
%reexported binding, i.e., an export imported from another library, are the
%same as the effective import levels of that binding within the reexporting
%library.
Уровнем экспорта экспортируемой привязки является $0$ для всех привязок, определённых внутри
экспортируемой библиотеки. Уровни зкспорта реэкспортированной привязки, то есть, экспорта,
импортированного из другой библиотеки, являются такими же, как и эффективные уровни импорта этой
привязки внутри реэкспортируемой библиотеки.

%For the libraries defined in the library report, the export level is
%$0$ for nearly all bindings. The exceptions are {\cf syntax-rules},
%{\cf identifier-syntax}, {\cf ...}, and {\cf \_} from the
%\rsixlibrary{base} library, which are exported with level $1$, {\cf
%  set!} from the \rsixlibrary{base} library, which is exported with
%levels $0$ and $1$, and all bindings from the composite
%\thersixlibrary{} library (see library
%chapter~\extref{lib:complibchapter}{Composite library}), which are
%exported with levels $0$ and $1$.
Уровнем экспорта практически всех привязок библиотек, определённых в библиотечном стандарте,
является $0$. Исключениями являются {\cf\bfseries syntax-rules}, {\cf\bfseries
  identifier-syntax}, {\cf\bfseries ...} и {\cf\bfseries \_} из библиотеки
\textbf{\rsixlibrary{base}}, экспортируемые с уровнем $1$, {\cf\bfseries set!} из библиотеки
\textbf{\rsixlibrary{base}}, экспортируемая с уровнями $0$ и $1$, и все привязки из композитной
библиотеки \textbf{\thersixlibrary{}} (см. библиотечную
главу~\extref{lib:complibchapter}{Composite library}), экспортируемые с уровнями $0$ и $1$.

%Macro expansion within a library can introduce a reference to an
%identifier that is not explicitly imported into the library. In that
%case, the phase of the reference must match the identifier's level as
%shifted by the difference between the phase of the source library
%(i.e., the library that supplied the identifier's lexical context) and
%the library that encloses the reference. For example, suppose that
%expanding a library invokes a macro transformer, and the evaluation of
%the macro transformer refers to an identifier that is exported from
%another library (so the phase-$1$ instance of the library is used);
%suppose further that the value of the binding is a syntax object
%representing an identifier with only a level-$n$ binding; then, the
%identifier must be used only at phase $n+1$ in the
%library being expanded. This combination of levels and phases is why
%negative levels on identifiers can be useful, even though libraries
%exist only at non-negative phases.
Разворачивание макроса внутри библиотеки может ввести обращение к идентификатору, явно не
импортированному в библиотеку. В этом случае фаза обращения должна соответствовать уровню
идентификатора, сдвинутому на разность фаз исходной библиотеки (то есть, библиотеки,
предоставляющей лексический контекст идентификатора) и библиотеки, содержащей
обращение. Например, предположим, что при разворачивании библиотеки запускается
макротрансформер, и при вычислении макротрансформера происходит обращение к
идентификатору, экспортируемому из другой библиотеки (таким образом, используется экземпляр
библиотеки фазы $1$); предположим также, что значением привязки является синтаксический объект,
представляющий идентификатор с привязкой только уровня $n$; тогда, в разворачиваемой библиотеке
идентификатор должен использоваться только в фазе $n+1$. Поэтому при такой комбинации уровней и
фаз могут применяться отрицательные уровни идентификаторов, несмотря на то, что библиотеки
существуют только в неотрицательных фазах.

%If any of a library's definitions are referenced at phase $0$ in the
%expanded form of a program, then an instance of the referenced library
%is created for phase $0$ before the program's definitions and
%expressions are evaluated. This rule applies transitively: if the
%expanded form of one library references at phase $0$ an identifier
%from another library, then before the referencing library is
%instantiated at phase $n$, the referenced library must be instantiated
%at phase $n$. When an identifier is referenced at any phase $n$
%greater than $0$, in contrast, then the defining library is
%instantiated at phase $n$ at some unspecified time before the
%reference is evaluated. Similarly, when a macro keyword is referenced at
%phase $n$ during the expansion of a library, then the
%defining library is visited at phase $n$ at some unspecified time
%before the reference is evaluated.
При обращении из развёрнутой формы программы к какому-либо библиотечному определению в фазе $0$,
перед вычислением определений и выражений программы создаётся экземпляр адресуемой библиотеки
для фазы $0$. Это правило применяется транзитивно: при обращении из развёрнутой формы некоторой
библиотеки в фазе $0$ к идентификатору из другой библиотеки, перед инстанцированием библиотеки
обращения в фазе $n$, должна инстанцироваться адресуемая библиотека в фазе $n$. При обращении к
идентификатору в некоторой фазе $n$, большей чем $0$, напротив, библиотека определения
инстанцируется в фазе $n$ в произвольное неспецифицированное время до вычисления
обращения. Аналогично, при обращении к ключевому слову макроса в фазе $n$ в течение разворачивания
библиотеки, библиотека определения посещается в фазе $n$ в произвольное неспецифицированное
время до вычисления обращения.

%An implementation may distinguish instances/visits of a library for
%different phases or to use an instance/visit at any phase as an instance/visit at
%any other phase. An implementation may further
%expand each {\cf library} form with distinct
%visits of libraries in any phase and/or instances of
%libraries in phases above $0$. An implementation may
%create instances/visits of more libraries at more phases than required to
%satisfy references. When an identifier appears as an expression in a
%phase that is inconsistent with the identifier's level, then an
%implementation may raise an exception either at expand time or run
%time, or it may allow the reference. Thus, a library whose meaning depends on whether the
%instances of a library are distinguished or shared across phases or
%{\cf library} expansions may be unportable.
Реализация может разделять экземпляры/посещения библиотек разных фаз или же
использовать экземпляр/посещение любой фазы как экземпляр/посещение любой другой
фазы. Реализация может также разворачивать каждую форму {\cf\bfseries library} с разными
посещениями библиотек в любой фазе и/или экземпляры библиотек в фазах выше $0$. Реализация
может создавать экземпляры/посещения большего количества библиотек в большем количестве фаз, чем
необходимо для удовлетворения обращений. Если идентификатор находится как выражение в фазе,
противоречащей уровню идентификатора, реализация может возбудить исключение на этапе разворачивания
или на этапе выполнения, или же она может позволить обращение. Таким образом, библиотека,
содержание которой зависит от того, различаются ли экземпляры библиотек, или же разделяется при
разворачивания фаз или {\cf\bfseries library}, может быть непортируемой.\vspace{-4mm}

%\section{Examples}
\section{Примеры}

%Examples for various \hyper{import~spec}s and \hyper{export~spec}s:
Примеры различных \hyper{import~spec} и \hyper{export~spec}:

{%
\renewcommand{\baselinestretch}{1.04}
\selectfont
\begin{scheme}
\bfseries (library (stack)
\bfseries   (export make push! pop! empty!)
\bfseries   (import (rnrs))
\bfseries
\bfseries   (define (make) (list '()))
\bfseries   (define (push! s v) (set-car! s (cons v (car s))))
\bfseries   (define (pop! s) (let ([v (caar s)])
\bfseries                      (set-car! s (cdar s))
\bfseries                      v))
\bfseries   (define (empty! s) (set-car! s '())))
%\end{scheme}
%\newpage
%\begin{scheme}
\bfseries (library (balloons)
\bfseries   (export make push pop)
\bfseries   (import (rnrs))
\bfseries
\bfseries   (define (make w h) (cons w h))
\bfseries   (define (push b amt)
\bfseries     (cons (- (car b) amt) (+ (cdr b) amt)))
\bfseries   (define (pop b) (display "Boom! ")
\bfseries                   (display (* (car b) (cdr b)))
\bfseries                   (newline)))

\bfseries (library (party)
\bfseries   ;; Total exports:
\bfseries   ;; make, push, push!, make-party, pop!
\bfseries   (export (rename (balloon:make make)
\bfseries                   (balloon:push push))
\bfseries           push!
\bfseries           make-party
\bfseries           (rename (party-pop! pop!)))
\bfseries   (import (rnrs)
\bfseries           (only (stack) make push! pop!) ; not empty!
\bfseries           (prefix (balloons) balloon:))
\bfseries
\bfseries   ;; Creates a party as a stack of balloons,
\bfseries   ;; starting with two balloons
\bfseries   (define (make-party)
\bfseries     (let ([s (make)]) ; from stack
\bfseries       (push! s (balloon:make 10 10))
\bfseries       (push! s (balloon:make 12 9))
\bfseries       s))
\bfseries   (define (party-pop! p)
\bfseries     (balloon:pop (pop! p))))


\bfseries (library (main)
\bfseries   (export)
\bfseries   (import (rnrs) (party))
\bfseries
\bfseries   (define p (make-party))
\bfseries   (pop! p)        ; displays "Boom! 108"
\bfseries   (push! p (push (make 5 5) 1))
\bfseries   (pop! p))       ; displays "Boom! 24"%
\end{scheme}

}%\vspace{-1mm}

%Examples for macros and phases:
Примеры макросов и фаз:%\vspace{-1mm}

{%
\renewcommand{\baselinestretch}{1.04}
\selectfont
\begin{schemenoindent}
\bfseries (library (my-helpers id-stuff)
\bfseries   (export find-dup)
\bfseries   (import (rnrs))
\bfseries
\bfseries   (define (find-dup l)
\bfseries     (and (pair? l)
\bfseries          (let loop ((rest (cdr l)))
\bfseries            (cond
\bfseries             [(null? rest) (find-dup (cdr l))]
\bfseries             [(bound-identifier=? (car l) (car rest))
\bfseries              (car rest)]
\bfseries             [else (loop (cdr rest))])))))
\bfseries
\bfseries (library (my-helpers values-stuff)
\bfseries   (export mvlet)
\bfseries   (import (rnrs) (for (my-helpers id-stuff) expand))
\bfseries
\bfseries   (define-syntax mvlet
\bfseries     (lambda (stx)
\bfseries       (syntax-case stx ()
\bfseries         [(\_ [(id ...) expr] body0 body ...)
\bfseries          (not (find-dup (syntax (id ...))))
\bfseries          (syntax
\bfseries            (call-with-values
\bfseries                (lambda () expr)
\bfseries              (lambda (id ...) body0 body ...)))]))))
\bfseries
\bfseries (library (let-div)
\bfseries   (export let-div)
\bfseries   (import (rnrs)
\bfseries           (my-helpers values-stuff)
\bfseries           (rnrs r5rs))
\bfseries
\bfseries   (define (quotient+remainder n d)
\bfseries     (let ([q (quotient n d)])
\bfseries       (values q (- n (* q d)))))
\bfseries   (define-syntax let-div
\bfseries     (syntax-rules ()
\bfseries      [(\_ n d (q r) body0 body ...)
\bfseries       (mvlet [(q r) (quotient+remainder n d)]
\bfseries         body0 body ...)])))%
\end{schemenoindent}

}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End:
