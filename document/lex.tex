% Lexical structure
\hyphenation{white-space}
%%\vfill\eject
%\chapter{Lexical syntax and datum syntax}
\chapter{Лексический синтаксис и datum-синтаксис}
\label{readsyntaxchapter}

%The syntax of Scheme code is organized in three levels:
Синтаксис кода Scheme организован на трёх уровнях:\vspace{-3mm}
%
\begin{enumerate}
%\item the \textit{lexical syntax} that describes how a program text is split
%  into a sequence of lexemes,
\item \textit{Лексический синтаксис}, описывающий, как текст программы разбивается на
  последовательность лексем,
%\item the \textit{datum syntax}, formulated in terms of the lexical
%  syntax, that structures the lexeme sequence as a sequence of
%  \textit{syntactic data\mainindex{datum}\mainindex{syntactic
%      datum}}, where a syntactic datum is
%    a recursively structured entity,
\item \textit{Datum-синтаксис}, сформулированный в терминах лексического синтаксиса,
структурирующий последовательность лексем в виде последовательности \textit{синтаксических
  данных\mainindex{datum}\mainindex{syntactic datum}}, где
синтаксический datum является рекурсивно структурированным элементом,
%\item the \textit{program syntax} formulated in terms of the read
%  syntax, imposing further structure and assigning meaning to
%  syntactic data.
\item \textit{Программный синтаксис}, сформулированный в терминах синтаксиса считывания, задающий
  дальнейшую структуру и наполняющий смысловым содержанием синтаксические данные.
\end{enumerate}\vspace{-3mm}
%
%Syntactic data (also called \textit{external
%  representations\index{external representation}}) double
%as a notation for objects, and Scheme's \rsixlibrary{io ports} library
%(library section~\extref{lib:portsiosection}{Port I/O})
%provides the {\cf get-datum} and {\cf put-datum} procedures
%for reading and writing syntactic data, converting between their
%textual representation and the corresponding objects.
%Each syntactic datum represents a corresponding \defining{datum value}.
%A syntactic datum can be used in a program to obtain the corresponding
%datum value using {\cf quote} (see section~\ref{quote}).
Синтаксические данные (называемые также \textit{внешними представлениями\index{external
    representation}}) одновременно служат как формой записи объектов, так и библиотекой Scheme
{\bfseries\rsixlibrary{io ports}} (секция библиотек~\extref{lib:portsiosection}{Port I/O}),
предоставляющей процедуры {\cf\bfseries get-datum} и {\cf\bfseries put-datum} для чтения и
записи синтаксических данных, преобразовывая их из текстового представления в
соответствующие объекты, и наоборот. Каждый синтаксический datum представляет соответствующее
\defining{datum-значение}. Синтаксический datum может использоваться в программе для
получения соответствующего datum-значения с помощью {\cf\bfseries quote}
(см. секцию~\ref{quote}).

%Scheme source code consists of syntactic data and (non-significant) comments.
%Syntactic data in Scheme source code are called
%\textit{forms}\mainindex{form}.
%(A form nested inside another form is
%called a \defining{subform}.)
%Consequently, Scheme's syntax has the property that any sequence of
%characters that is a form is also a syntactic datum representing
%some object.  This can lead to confusion, since it may not be obvious
%out of context whether a given sequence of characters is intended to
%be a representation of objects or the text of a program.
%It is also a source of power, since it
%facilitates writing programs such as interpreters or compilers that
%treat programs as objects (or vice versa).
Исходный текст Scheme состоит из синтаксических данных и (незначащих)
комментариев. Синтаксические данные в исходном тексте Scheme называются
\textit{формами}\mainindex{form}. (Форма, вложенная в другую форму, называется
\defining{подформой}.) Следовательно, синтаксис Scheme обладает таким свойством, что любая
последовательность символов, являющаяся формой, является также и синтаксическим datum,
представляющим некоторый объект. Это может привести к путанице, так как из контекста может
быть не ясно, предназначена ли данная последовательность знаков для представления объектов или
текста программы. Это также и мощное вычислительное средство, так как облегчает написание
программ, таких, как интерпретаторы или компилятороы, интерпретирующих программы как объекты
(или наоборот).

%A datum value may have several different external representations.
%For example, both ``{\tt \#e28.000}'' and
%``{\tt\#x1c}'' are syntactic data representing the exact integer
%object 28, and the syntactic data ``{\tt(8 13)}'', ``{\tt( 08 13 )}'', ``{\tt(8 .\
%  (13 .\ ()))}''
%all represent a list containing the exact integer objects 8 and 13.
%Syntactic data that represent equal objects (in the sense of {\cf
%  equal?}; see section~\ref{equal?}) are always equivalent
%as forms of a program.
Datum-значение может иметь несколько различных внешних представлений. Например, и ``{\tt\bfseries
  \#e28.000}'', и ``{\tt\bfseries\#x1c}'' являются синтаксическими данными, представляющими
точный целый объект 28, а синтаксические данные ``{\tt\bfseries(8 13)}'', ``{\tt\bfseries( 08 13
  )}'', ``{\tt\bfseries(8 .\ (13 .\ ()))}'' представляют список, содержащий точные целые
объекты 8 и 13. Синтаксические данные, представляющие равные объекты (в смысле {\cf\bfseries
  equal?}; см. секцию~\ref{equal?}), всегда эквивалентны как формы программы.

%Because of the close correspondence between syntactic data and datum
%values, this report sometimes uses the term \defining{datum} for
%either a syntactic datum or a datum value when the exact meaning
%is apparent from the context.
Вследствие близкого соответствия синтаксических данных и datum-значений в данном стандарте термин
\defining{datum} иногда используется и для синтаксического datum, и для datum-значения, если
точный смысл очевиден из контекста.

%An implementation must not extend the lexical or datum syntax in
%any way, with one exception: it need not treat the syntax
%{\cf \sharpsign{}!\meta{identifier}}, for any \meta{identifier} (see
%section~\ref{identifiersection}) that is not {\cf r6rs}, as a syntax
%violation, and it may use specific {\cf \sharpsign{}!}-prefixed
%identifiers as flags indicating that subsequent input contains extensions
%to the standard lexical or datum syntax.
%The syntax {\cf \sharpsign{}!r6rs} may be used to signify that
%the input afterward is written with the lexical syntax and
%datum syntax described by
%this report.
%{\cf \sharpsign{}!r6rs} is otherwise treated as a comment; see section~\ref{whitespaceandcomments}.
Реализации запрещено расширять лексический или datum-синтаксис, за одним исключением: синтаксис
{\cf{\bfseries \sharpsign{}!}\meta{identifier}} при любом \meta{identifier} (см. секцию~\ref
{identifiersection}), отличном от {\cf\bfseries r6rs}, не должен считаться синтаксическим
нарушением, а специфические идентификаторы с префиксом {\cf\bfseries \sharpsign {}!} могут
использоваться в качестве флагов, указывающих на наличие в последующем вводе расширений
лексического стандарта или datum-синтаксиса. Синтаксис {\cf \sharpsign \bfseries{}!r6rs} может
применяться для указания, что последующий ввод записан с лексическим и datum-синтаксисом,
описанным в данном стандарте. В противном случае {\cf \sharpsign\bfseries {}!r6rs} считается
комментарием; см. секцию~\ref{whitespaceandcomments}.\vspace{-1mm}

%\section{Notation}
\section{Нотация}
\label{BNF}

%The formal syntax for Scheme is written in an extended BNF.
%Non-terminals are written using angle brackets.  Case is insignificant
%for non-terminal names.
Формальный синтаксис Scheme записан в расширенной BNF. Нетерминальные символы заключены в
угловые скобки. Для нетерминальных имён регистр не имеет значения.

%All spaces in the grammar are for legibility.
%\meta{Empty} stands for the empty string.
Все пробелы в грамматике применяются для удобочитаемости. \meta{Empty} обозначает пустую строку.

%The following extensions to BNF are used to make the description more
%concise:  \arbno{\meta{thing}} means zero or more occurrences of
%\meta{thing}, and \atleastone{\meta{thing}} means at least one
%\meta{thing}.
Для более лаконичного описания используются следующие расширения BNF: \arbno{\meta{thing}} означает
ноль или более вхождений \meta{thing}, а \atleastone{\meta{thing}} означает не менее
одного \meta{thing}.

%Some non-terminal names refer to the Unicode scalar values of the same
%name: \meta{character tabulation} (U+0009), \meta{linefeed} (U+000A),
%\meta{carriage return} (U+000D), \meta{line tabulation} (U+000B),
%\meta{form feed} (U+000C), \meta{carriage return} (U+000D),
%\meta{space} (U+0020), \meta{next line} (U+0085), \meta{line
%  separator} (U+2028), and \meta{paragraph separator} (U+2029).
Некоторые нетерминальные имена относятся к одноимённым скалярным значениям Unicode:
\meta{character tabulation} (U+0009), \meta{linefeed} (U+000A), \meta{carriage return} (U+000D),
\meta{line tabulation} (U+000B), \meta{form feed} (U+000C), \meta{carriage return} (U+000D),
\meta{space (U+0020)}, \meta{next line} (U+0085), \meta{line separator} (U+2028) и
\meta{paragraph separator} (U+2029).\vspace{-1mm}

%\section{Lexical syntax}
\section{Лексический синтаксис}
\label{lexicalsyntaxsection}

%The lexical syntax determines how a character sequence is split into a
%sequence of lexemes\index{lexeme}, omitting non-significant portions
%such as comments and whitespace.  The character sequence is assumed to
%be text according to the Unicode standard~\cite{Unicode}.  Some of
%the lexemes, such as identifiers, representations of number objects, strings etc., of the lexical
%syntax are syntactic data in the datum syntax, and thus represent objects.
%Besides the formal account of the syntax, this section also describes
%what datum values are represented by these syntactic data.
Лексический синтаксис определяет, как символьная последовательность разбивается на
последовательность лексем\index{lexeme} с пропуском незначащих частей, таких, как комментарии и
пробелы. Полагается, что символьная последовательность является текстом согласно стандарту
Unicode~\cite{Unicode}. Некоторые лексемы, такие, как идентификаторы, представления числовых
объектов, строки и т.д. лексического синтаксиса являются синтаксическими данными в
datum-синтаксисе и, таким образом, представляют объекты. Помимо формального описания
синтаксиса, в этой секции также описывается, какие datum-значения представляют эти синтаксические
данные.

%The lexical syntax, in the description of comments, contains
%a forward reference to \meta{datum}, which is described as part of the
%datum syntax.  Being comments, however, these \meta{datum}s do not play
%a significant role in the syntax.
Лексический синтаксис в описании комментариев содержит прямое обращение к \meta{datum},
описанное как часть datum-синтаксиса. Будучи комментариями, однако,
такие \meta{datum} не играют существенную роль в синтаксисе.

%Case is significant except in representations of booleans, number objects, and
%in hexadecimal numbers specifying Unicode scalar values.  For example, {\cf \#x1A}
%and {\cf \#X1a} are equivalent.  The identifier {\cf Foo} is, however,
%distinct from the identifier {\cf FOO}.
Регистр является значащим, за исключением представлений булевых выражений, числовых объектов и
шестнадцатеричных чисел, определяющих скалярные значения Unicode. Например, {\cf\bfseries \#x1A}
и {\cf\bfseries \#X1a} эквивалентны. А вот идентификатор {\cf\bfseries Foo} отличается от
идентификатора {\cf\bfseries FOO}.

%\subsection{Formal account}
\subsection{Формальное описание}
\label{lexicalgrammarsection}

%\meta{Interlexeme space} may occur on either side of any lexeme, but not
%within a lexeme.
\meta{Interlexeme space} может находиться с любой стороны лексемы, но не внутри лексемы

%\hyper{Identifier}s, {\cf .}, \hyper{number}s, \hyper{character}s, and
%\hyper{boolean}s, must be terminated by a \meta{delimiter} or by the
%end of the input.
\hyper{Identifier}, {\cf .}, \hyper{number}, \hyper{character} и
\hyper{boolean} могут заканчиваться \meta{delimiter} или концом ввода.

%The following two characters are reserved for future extensions to the
%language: {\tt \verb"{" \verb"}"}
Следующие два знака зарезервированы для будущих расширений языка:
{\tt\bfseries \verb"{" \verb"}"}

{%
\renewcommand{\baselinestretch}{1.08}
\selectfont
\begin{grammar}%
\meta{lexeme} \: \meta{identifier} \| \meta{boolean} \| \meta{number}\index{identifier}
\>  \| \meta{character} \| \meta{string}
\>  \| \textbf{(} \| \textbf{)} \| \textbf{\openbracket{}} \| \textbf{\closedbracket{}} \| %
\textbf{\sharpsign(} \| \textbf{\sharpsign{}vu8(} | \textbf{\singlequote{}} \| %
\textbf{\backquote{}} \| \textbf{,} \| \textbf{,@} \| {\bf\bfseries.}
\>  \| \textbf{\sharpsign\singlequote{}} \| \textbf{\sharpsign\backquote{}} \| %
\textbf{\sharpsign,} \| \textbf{\sharpsign,@}
\meta{delimiter} \: \textbf{(} \| \textbf{)} \| \textbf{\openbracket{}} \| %
\textbf{\closedbracket{}} \| \textbf{"} \| \textbf{;} \| \textbf{\sharpsign{}}
\>  \| \meta{whitespace}
\meta{whitespace} \: \meta{character tabulation}
\> \| \meta{linefeed} \| \meta{line tabulation} \| \meta{form feed}
\> \| \meta{carriage return} \| \meta{next line}
\> \| \meta{any character whose category is Zs, Zl, or Zp}
\meta{line ending} \: \meta{linefeed} \| \meta{carriage return}
\> \| \meta{carriage return} \meta{linefeed} \| \meta{next line}
\> \| \meta{carriage return} \meta{next line} \| \meta{line separator}
\meta{comment} \: ; \= $\langle$\rm all subsequent characters up to a
                    \>\ \rm \meta{line ending} or \meta{paragraph separator}$\rangle$\index{comment}
\qquad \= \| \meta{nested comment}
\> \| \textbf{\#}; \meta{interlexeme space} \meta{datum}
\> \| \textbf{\#!r6rs}
\meta{nested comment} \: \textbf{\#|} \= \meta{comment text}
\> \arbno{\meta{comment cont}} \textbf{|\#}
\meta{comment text} \: \= $\langle$\rm character sequence not containing
\>\ \rm {\tt\bfseries \#|} or {\tt\bfseries |\#}$\rangle$
\meta{comment cont} \: \meta{nested comment} \meta{comment text}
\meta{atmosphere} \: \meta{whitespace} \| \meta{comment}
\meta{interlexeme space} \: \arbno{\meta{atmosphere}}%
\end{grammar}

\label{extendedalphas}
\label{identifiersyntax}

% This is a kludge, but \multicolumn doesn't work in tabbing environments.
\setbox0\hbox{\cf\meta{variable} \goesto{} $\langle$}

\begin{grammar}%
\meta{identifier} \: \meta{initial} \arbno{\meta{subsequent}}
 \>  \| \meta{peculiar identifier}
\meta{initial} \: \meta{constituent} \| \meta{special initial}
 \> \| \meta{inline hex escape}
\meta{letter} \:  \textbf{a} \| \textbf{b} \| \textbf{c} \| ... \| \textbf{z}
\> \| \textbf{A} \| \textbf{B} \| \textbf{C} \| ... \| \textbf{Z}
\meta{constituent} \: \meta{letter}
 \> \| $\langle${\rm any character whose Unicode scalar value is greater than}
 \> \quad {\rm 127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,}
 \> \quad {\rm Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co}$\rangle$
%\end{grammar}
%
%\newpage
%
%\begin{grammar}
\meta{special initial} \: \textbf{!} \| \textbf{\$} \| \textbf{\%} \| {\bfseries\verb"&"} \| %
\textbf{*} \| \textbf{/} \| \textbf{:} \| \textbf{<} \| \textbf{=}
 \>  \| \textbf{>} \| \textbf{?} \| {\bfseries\verb"^"} \| {\bfseries\verb"_"} \| {\bfseries\verb"~"}
\meta{subsequent} \: \meta{initial} \| \meta{digit}
 \>  \| \meta{any character whose category is Nd, Mc, or Me}
 \>  \| \meta{special subsequent}
\meta{digit} \: \textbf{0} \| \textbf{1} \| \textbf{2} \| \textbf{3} \| \textbf{4} \| \textbf{5} %
\| \textbf{6} \| \textbf{7} \| \textbf{8} \| \textbf{9}
\meta{hex digit} \: \meta{digit}
 \> \| \textbf{a} \| \textbf{A} \| \textbf{b} \| \textbf{B} \| \textbf{c} \| \textbf{C} \| %
 \textbf{d} \| \textbf{D} \| \textbf{e} \| \textbf{E} \| \textbf{f} \| \textbf{F}
\meta{special subsequent} \: \textbf{+} \| \textbf{-} \| \textbf{.}\ \| \textbf{@}
\meta{inline hex escape} \: {\bfseries\backwhack{}x}\meta{hex scalar value};
\meta{hex scalar value} \: \atleastone{\meta{hex digit}}
\meta{peculiar identifier} \: \textbf{+} \| \textbf{-} \| ... \| \textbf{->} \arbno{\meta{subsequent}}
\meta{boolean} \: {\bfseries\schtrue{}} \| \bfseries{\#T} \| {\bfseries\schfalse{}} \| {\bfseries\#F}
\meta{character} \: {\bfseries\#\backwhack{}}\meta{any character}
 \>  \| {\bfseries\#\backwhack{}}\meta{character name}
 \>  \| {\bfseries\#\backwhack{}x}\meta{hex scalar value}
\meta{character name} \: \textbf{nul} \| \textbf{alarm} \| \textbf{backspace} \| \textbf{tab}
\> \| \textbf{linefeed} \| \textbf{newline} \| \textbf{vtab} \| \textbf{page} \| \textbf{return}
\> \| \textbf{esc} \| \textbf{space} \| \textbf{delete}
\meta{string} \: " \arbno{\meta{string element}} "
\meta{string element} \: \meta{any character other than {\bfseries\doublequote{}} or {\bfseries\backwhack}}
 \> \| {\bfseries\backwhack{}a} \| {\bfseries\backwhack{}b} \| {\bfseries\backwhack{}t} \| %
 {\bfseries\backwhack{}n} \| {\bfseries\backwhack{}v} \| {\bfseries\backwhack{}f} \| {\bfseries\backwhack{}r}
 \>  \| {\bfseries\backwhack\doublequote{}} \| {\bfseries\backwhack\backwhack}
 \>  \| {\bfseries\backwhack}\meta{intraline whitespace}\meta{line ending}
 \>  \hspace*{4em}\meta{intraline whitespace}
 \>  \| \meta{inline hex escape}
\meta{intraline whitespace} \: \meta{character tabulation}
\> \| \meta{any character whose category is Zs}%
\end{grammar}

}

%A \meta{hex scalar value} represents a Unicode scalar value
%between 0 and \sharpsign{}x10FFFF, excluding the range
%$\left[\sharpsign{}x\textrm{D800}, \sharpsign{}x\textrm{DFFF}\right]$.
\meta{hex scalar value} представляет собой скалярное значение Unicode
между 0 и \sharpsign{}x10FFFF, за исключением диапазона
$\left[\sharpsign{}x\textrm{D800}, \sharpsign{}x\textrm{DFFF}\right]$.

\label{numbersyntax}%
%The rules for \meta{num $R$}, \meta{complex $R$}, \meta{real
%$R$}, \meta{ureal $R$}, \meta{uinteger $R$}, and \meta{prefix $R$} below
%should be replicated for \hbox{$R = 2, 8, 10,$}
%and $16$.  There are no rules for \meta{decimal $2$}, \meta{decimal
%$8$}, and \meta{decimal $16$}, which means that number representations containing
%decimal points or exponents must be in decimal radix.
Правила для \meta{num $R$}, \meta{complex $R$}, \meta{real $R$}, \meta{ureal $R$},
\meta{uinteger $R$} и \meta{prefix $R$} ниже должны быть дублированы для \hbox{$R = 2, 8, 10$}
и $16$.  Не существует правил для \meta{decimal $2$}, \meta{decimal $8$} и \meta{decimal $16$},
что означает, что представления чисел, содержащих десятичные точки или экспоненты
должны быть с десятичным основанием.

\begin{grammar}%
\meta{number} \: \meta{num $2$} \| \meta{num $8$}
   \>  \| \meta{num $10$} \| \meta{num $16$}
\meta{num $R$} \: \meta{prefix $R$} \meta{complex $R$}
\meta{complex $R$} \: %
         \meta{real $R$} %
      \| \meta{real $R$} \textbf{@} \meta{real $R$}
   \> \| \meta{real $R$} \textbf{+} \meta{ureal $R$} \textbf{i} %
      \| \meta{real $R$} \textbf{-} \meta{ureal $R$} \textbf{i}
   \> \| \meta{real $R$} \textbf{+} \meta{naninf} \textbf{i} %
      \| \meta{real $R$} \textbf{-} \meta{naninf} \textbf{i}
   \> \| \meta{real $R$} \textbf{+ i} %
      \| \meta{real $R$} \textbf{- i}
   \> \| \textbf{+} \meta{ureal $R$} \textbf{i} %
      \| \textbf{-} \meta{ureal $R$} \textbf{i}
   \> \| \textbf{+} \meta{naninf} \textbf{i} %
      \| \textbf{-} \meta{naninf} \textbf{i}
   \> \| \textbf{+ i} %
      \| \textbf{- i}
\meta{real $R$} \: \meta{sign} \meta{ureal $R$}
  \> \| \textbf{+} \meta{naninf} \| \textbf{-} \meta{naninf}
\meta{naninf} \: \textbf{nan.0} \| \textbf{inf.0}
\meta{ureal $R$} \: %
         \meta{uinteger $R$}
   \> \| \meta{uinteger $R$} / \meta{uinteger $R$}
   \> \| \meta{decimal $R$} \meta{mantissa width}
\meta{decimal $10$} \: %
         \meta{uinteger $10$} \meta{suffix}
   \> \| \textbf{.} \atleastone{\meta{digit $10$}} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} \textbf{.} \arbno{\meta{digit $10$}} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} \textbf{.} \meta{suffix}
\meta{uinteger $R$} \: \atleastone{\meta{digit $R$}}
\meta{prefix $R$} \: %
         \meta{radix $R$} \meta{exactness}
   \> \| \meta{exactness} \meta{radix $R$}
\end{grammar}

\begin{grammar}%
\meta{suffix} \: \meta{empty}
   \> \| \meta{exponent marker} \meta{sign} \atleastone{\meta{digit $10$}}
\meta{exponent marker} \: \textbf{e} \| \textbf{E} \| \textbf{s} \| \textbf{S} \| \textbf{f} \| \textbf{F}
   \> \| \textbf{d} \| \textbf{D} \| \textbf{l} \| \textbf{L}
\meta{mantissa width} \: \meta{empty}
   \> \| \textbf{|} \atleastone{\meta{digit 10}}
\meta{sign} \: \meta{empty}  \| \textbf{+} \|  \textbf{-}
\meta{exactness} \: \meta{empty}
   \> \| {\bfseries\#i\sharpindex{i}} \| {\bfseries\#I} \| {\bfseries\#e\sharpindex{e}} \| {\bfseries\#E}
\meta{radix 2} \: {\bfseries\#b\sharpindex{b}} \| {\bfseries\#B}
\meta{radix 8} \: {\bfseries\#o\sharpindex{o}} \| {\bfseries\#O}
\meta{radix 10} \: \meta{empty} \| {\bfseries\#d} \| {\bfseries\#D}
\meta{radix 16} \: {\bfseries\#x\sharpindex{x}} \| {\bfseries\#X}
\meta{digit 2} \: \textbf{0} \| \textbf{1}
\meta{digit 8} \: \textbf{0} \| \textbf{1} \| \textbf{2} \| \textbf{3} \| \textbf{4} \| %
\textbf{5} \| \textbf{6} \| \textbf{7}
\meta{digit 10} \: \meta{digit}
\meta{digit 16} \: \meta{hex digit}
\end{grammar}

%\subsection{Line endings}
\subsection{Окончания строк}
\label{lineendings}

%Line endings are significant in Scheme in single-line comments (see
%section~\ref{whitespaceandcomments}) and within string literals.  In
%Scheme source code, any of the line endings in \meta{line ending}
%marks the end of a line.  Moreover, the two-character line endings
%\meta{carriage return} \meta{linefeed} and \meta{carriage return}
%\meta{next line} each count as a single line ending.
В Scheme окончания строк являются значащими в однострочных комментариях
(см. секцию~\ref{whitespaceandcomments}) и внутри строковых литералов. В исходном тексте Scheme
любые окончания строк в \meta{line ending} означают конец строки. Кроме того, двухсимвольные
окончания строк \meta{carriage return} \meta{linefeed} и \meta{carriage return} \meta{next
  line} считаются одним окончанием строки.

%In a string literal, a \hyper{line ending} not preceded by a {\cf\backwhack}
%stands for a linefeed character, which is the standard line-ending
%character of Scheme.
В строковом литерале \hyper{line ending} без {\cf\backwhack} перед ним обозначает
символ перевода строки -- стандартный символ конца строки Scheme.

%\subsection{Whitespace and comments}
\subsection{Пробельные символы и комментарии}
\label{whitespaceandcomments}

%\defining{Whitespace} characters are spaces, linefeeds,
%carriage returns, character tabulations, form feeds, line tabulations,
%and any other character whose category is Zs, Zl, or Zp.
%Whitespace is used for improved readability and
%as necessary to separate lexemes from each other.  Whitespace may
%occur between any two lexemes,
%but not within a lexeme.  Whitespace may also occur inside a string,
%where it is significant.
\defining{Пробельными} символами являются пробелы, обратные переводы строк, переводы каретки, символы
табуляции, переводы страницы, линейные табуляции и любой другой символ, категорией которого является Zs,
Zl или Zp. Пробельные символы используются для улучшения читаемости и при необходимости
отделения лексем друг от друга. Пробельные символы могут находиться между любыми двумя
лексемами, но не внутри лексемы. Пробельный символ может также находиться в строке, где он
является значащим.

%The lexical syntax includes several comment forms. In all cases,
%comments are invisible to Scheme, except that they act as delimiters,
%so, for example, a comment cannot appear in the middle of an
%identifier or representation of a number object.
Лексический синтаксис включает несколько форм комментариев. В Sheme комментарии всегда
невидимы, за исключением того, что они действуют как разделители, так, например, комментарий не
может находиться в середине идентификатора или представления числового объекта.

%\newpage

%A semicolon ({\tt;}) indicates the start of a line
%comment.\mainindex{comment}\mainschindex{;} The comment continues to
%the end of the line on which the semicolon appears.
Точка с запятой ({\tt;}) задаёт начало строки комментария.\mainindex{comment}\mainschindex{;}
Комментарий продолжается до конца строки, на которой находится точка с запятой.\vspace{1mm}

%Another way to indicate a comment is to prefix a \hyper{datum}
%(cf.\ section~\ref{datumsyntax}) with {\tt \#;}\sharpindex{;}, possibly with
%\meta{interlexeme space} before the \hyper{datum}.  The comment consists of
%the comment prefix {\tt \#;} and the \hyper{datum} together.  This
%notation is useful for ``commenting out'' sections of code.
Другим способом задания комментария является добавление к \hyper{datum} (см.\ секцию~\ref
{datumsyntax}) префикса {\tt\bfseries \#;}\sharpindex{;}, возможно, с \meta{interlexeme space} перед
\hyper{datum}. Комментарий состоит из приставки комментария {\tt\bfseries \#;} и \hyper{datum}.
Такая нотация применяется для ``комментирования'' секций кода.\vspace{1mm}

%Block comments may be indicated with properly nested {\tt
%  \#|}\index{#"|@\texttt{\sharpsign\verticalbar}}\index{"|#@\texttt{\verticalbar\sharpsign}}
%and {\tt |\#} pairs.
Блоковые комментарии могут задаваться согласовано вложенными парами {\tt\bfseries \#|}
\index{#"|'@\texttt{\sharpsign\verticalbar}}\index{"|#@\texttt{\verticalbar\sharpsign}} и {\tt\bfseries |\#}.\vspace{1mm}

\begin{scheme}
\bfseries\#|
\bfseries   The FACT procedure computes the factorial
\bfseries   of a non-negative integer.
\bfseries|\#
\bfseries(define fact
\bfseries  (lambda (n)
\bfseries    ;; base case
\bfseries    (if (= n 0)
\bfseries        \#;(= n 1)
\bfseries        1       ; identity of *
\bfseries        (* n (fact (- n 1))))))%
\end{scheme}\vspace{1mm}

%The lexeme {\cf \sharpsign{}!r6rs}, which signifies that the program text
%that follows is written with the lexical and datum syntax described in this
%report, is also otherwise treated as a comment.
Лексема {\cf\bfseries \sharpsign{}!r6rs}, означающая, что текст следующей далее программы
записан с лексическим и datum-синтаксисом, описанным в данном стандарте, в других случаях
также интерпретируется как комментарий.\vspace{1mm}

%\subsection{Identifiers}
\subsection{Идентификаторы}\vspace{1mm}
\label{identifiersection}

%Most identifiers\mainindex{identifier} allowed by other programming
%languages are also acceptable to Scheme.  In general,
%a sequence of letters, digits, and ``extended alphabetic
%characters'' is
%an identifier when it begins with a character that cannot begin a
%representation of a number object.
%In addition, \ide{+}, \ide{-}, and \ide{...} are identifiers, as is
%a sequence of letters, digits, and extended alphabetic
%characters that begins with the two-character sequence \ide{->}.
%Here are some examples of identifiers:
Большинство идентификаторов\mainindex{identifier}, допустимых в других языках программирования,
также допустимы и в Scheme. В общем случае последовательность букв, цифр и ``расширенных алфавитных
символов'' является идентификатором, если она начинается с символа, с которого не может начинаться
представление числового объекта. Кроме того, идентификаторами являются \ide{+}, \ide{-} и \ide{...},
равно как и последовательность букв, цифр и расширенных алфавитных символов, начинающаяся
с двухсимвольной последовательности \ide{->}. Несколько примеров идентификаторов:\vspace{1mm}

\begin{scheme}
\bfseries lambda         q                soup
\bfseries list->vector   {+}                V17a
\bfseries <=             a34kTMNs         ->-
\bfseries the-word-recursion-has-many-meanings%
\end{scheme}\vspace{1mm}

%Extended alphabetic characters may be used within identifiers as if
%they were letters.  The following are extended alphabetic characters:
Расширенные алфавитные символы могут использоваться внутри идентификаторов, как если бы они
были буквами. Расширенными алфавитными символами являются:\vspace{1mm}

\begin{scheme}
\bfseries !\ \$ \% \verb"&" * + - . / :\ < = > ? @ \verb"^" \verb"_" \verb"~" %
\end{scheme}\vspace{1mm}

%Moreover, all characters whose Unicode scalar values are greater than 127 and
%whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Pd,
%Pc, Po, Sc, Sm, Sk, So, or Co can be used within identifiers.
%In addition, any character can be used within an identifier
%when specified via an \meta{inline hex escape}.  For example, the
%identifier \verb|H\x65;llo| is the same as the identifier
%\verb|Hello|, and the identifier \verb|\x3BB;| is the same as the
%identifier $\lambda$.
Кроме того, в идентификаторах могут использоваться все символы, скалярные значения Unicode
которых больше 127, и с категорией Unicode Lu, ~Ll, ~Lt, ~Lm, ~Lo, ~Mn, ~Mc, ~Me, ~Nd, ~Nl, ~No, ~Pd, ~Pc,
~Po, ~Sc, ~Sm, ~Sk, ~So или ~Co. Кроме того, в идентификаторе может использоваться любой символ, если
он специфицирован посредством \meta{inline hex escape}. Например, идентификаторы
{\bfseries\verb|H\x65;llo|} и {\bfseries\verb|Hello|} аналогичны, также аналогичны
идентификаторы {\bfseries\verb|\x3BB;|} и {\bfseries
  $\lambda$}.~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~
~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~ ~~~~~~~~~~
~~~~~~~~~~

%Any identifier may be used as a variable\index{variable} or as a
%syntactic keyword\index{syntactic keyword} (see
%sections~\ref{variablesection} and~\ref{macrosection}) in a Scheme
%program.
%Any identifier may also be used as a syntactic datum, in which case it
%represents a \textit{symbol}\index{symbol} (see section~\ref{symbolsection}).
В программе Scheme любой идентификатор может использоваться как переменная\index{variable} или
как синтаксическое ключевое слово\index{syntactic keyword} (см. секции~\ref{variablesection}
и~\ref{macrosection}). Любой идентификатор может также использоваться как синтаксический datum,
в этом случае он представляет собой \textit{символ}\index{symbol} (см. секцию~\ref{symbolsection}).

\subsection{Булевы значения}

%The standard boolean objects for true and false have external representations
%\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}
Стандартные булевые объекты для true и false имеют внешние представления {\bfseries\schtrue{}} и
{\bfseries\schfalse}.\sharpindex{t}\sharpindex{f}

\subsection{Символы}

%Characters are represented using the notation
%\sharpsign\backwhack\hyper{character}\index{#\@\texttt{\sharpsign\backwhack}} or
%\sharpsign\backwhack\hyper{character name} or
%\sharpsign\backwhack{}x\meta{hex scalar value}.
Символы представляются с помощью нотации
{\bfseries\sharpsign\backwhack}\hyper{character}\index{#\@\texttt{\sharpsign\backwhack}} или
{\bfseries\sharpsign\backwhack}\hyper{character name} или
{\bfseries\sharpsign\backwhack{}x}\meta{hex scalar value}.

%For example:
Например:

\texonly
\newcommand{\extab}{\>}
{%
\renewcommand{\baselinestretch}{1.05}
\selectfont
\begin{tabbing}
{\cf\#\backwhack{}x0000000000}\=\kill
\endtexonly
\htmlonly
\newcommand{\extab}{&}
\begin{tabular}{ll}
\endhtmlonly
{\cf\bfseries\#\backwhack{}a}          \extab \textrm{lower case letter a}\\
{\cf\bfseries\#\backwhack{}A}          \extab \textrm{upper case letter A}\\
{\cf\bfseries\#\backwhack{}(}          \extab \textrm{left parenthesis}\\
{\cf\bfseries\#\backwhack{}}           \extab \textrm{space character}\\
{\cf\bfseries\#\backwhack{}nul}        \extab \textrm{U+0000}\\
{\cf\bfseries\#\backwhack{}alarm}      \extab \textrm{U+0007}\\
{\cf\bfseries\#\backwhack{}backspace}  \extab \textrm{U+0008}\\
{\cf\bfseries\#\backwhack{}tab}        \extab \textrm{U+0009}\\
{\cf\bfseries\#\backwhack{}linefeed}   \extab \textrm{U+000A}\\
{\cf\bfseries\#\backwhack{}newline}   \extab \textrm{U+000A}\\
{\cf\bfseries\#\backwhack{}vtab}       \extab \textrm{U+000B}\\
{\cf\bfseries\#\backwhack{}page}       \extab \textrm{U+000C}\\
{\cf\bfseries\#\backwhack{}return}     \extab \textrm{U+000D}\\
{\cf\bfseries\#\backwhack{}esc}        \extab \textrm{U+001B}\\
{\cf\bfseries\#\backwhack{}space}      \extab \textrm{U+0020}\\
 \extab preferred way to write a space\\
{\cf\bfseries\#\backwhack{}delete}     \extab \textrm{U+007F}\\[1ex]
{\cf\bfseries\#\backwhack{}xFF}        \extab \textrm{U+00FF}\\
{\cf\bfseries\#\backwhack{}x03BB}      \extab \textrm{U+03BB}\\
{\cf\bfseries\#\backwhack{}x00006587}  \extab \textrm{U+6587}\\
{\cf\bfseries\#\backwhack{}\(\lambda\)} \extab \textrm{U+03BB}\\[1ex]
{\cf\bfseries\#\backwhack{}x0001z}     \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}\(\lambda\)x}         \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}alarmx}     \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}alarm x}    \extab \textrm{U+0007}\\
 \extab followed by {\cf{}x}\\
{\cf\bfseries\#\backwhack{}Alarm}      \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}alert}      \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}xA}         \extab \textrm{U+000A}\\
{\cf\bfseries\#\backwhack{}xFF}        \extab \textrm{U+00FF}\\
{\cf\bfseries\#\backwhack{}xff}        \extab \textrm{U+00FF}\\
{\cf\bfseries\#\backwhack{}x ff}       \extab \textrm{U+0078}\\
 \extab followed by another datum, {\bfseries\cf{}ff}\\%%%%%%%%%%%%%%%%%%%[34mm]%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\cf\bfseries\#\backwhack{}x(ff)}      \extab \textrm{U+0078}\\
 \extab followed by another datum,\\
 \extab a parenthesized {\bfseries\cf{}ff}\\
{\cf\bfseries\#\backwhack{}(x)}        \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}(x}         \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}((x)}       \extab \textrm{U+0028}\\
 \extab followed by another datum,\\
 \extab parenthesized {\bfseries\cf{}x}\\
{\cf\bfseries\#\backwhack{}x00110000}  \extab \exception{\bfseries\&lexical}\\
 \extab out of range\\
{\cf\bfseries\#\backwhack{}x000000001} \extab \textrm{U+0001}  \\
{\cf\bfseries\#\backwhack{}xD800}      \extab \exception{\bfseries\&lexical}\\
 \extab in excluded range
\htmlonly
\end{tabular}
\endhtmlonly
\texonly
\end{tabbing}

}
\endtexonly



%(The notation \exception{\&lexical} means that the line in question is
%a lexical syntax violation.)
(Нотация \exception{\bfseries\&lexical} означает, что рассматриваемая строка является
лексическим нарушением синтаксиса.)

%Case is significant in \sharpsign\backwhack\hyper{character}, and in
%\sharpsign\backwhack{\rm$\langle$character name$\rangle$}, % \hyper doesn't allow a linebreak
%but not in {\cf\sharpsign\backwhack{}x}\meta{hex scalar value}.
%A \meta{character} must be followed by a \meta{delimiter} or by the end of the input.
%This rule resolves various ambiguous cases involving named characters,
%requiring, for
%example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
%to be interpreted as the space character rather than as
%the character ``{\tt\sharpsign\backwhack s}'' followed
%by the identifier ``{\tt pace}''.
Регистр является значащим в {\bfseries\sharpsign\backwhack}\hyper{character} и в
{\bfseries\sharpsign\backwhack} {\rm$\langle$character name$\rangle$}, но не в
{\bfseries\cf\sharpsign\backwhack{}x}\meta{hex scalar value}. За \meta{character} должен находиться
\meta{delimeter} или конец ввода. Это правило разрешает различные неоднозначные ситуации с
именованными символами, оно требует, например, чтобы последовательность символов
``{\bfseries\tt\sharpsign\backwhack space}'' интерпретировалась как символ пробела, а не как символ
``{\bfseries\tt\sharpsign\backwhack s}''и назодящийся за ним идентификатор ``{\bfseries\tt pace}''.

\begin{note}
  %The {\cf\sharpsign\backwhack{}newline} notation is retained for
  %backward compatibility.  Its use is deprecated;
  %{\cf\sharpsign\backwhack{}linefeed} should be used instead.
  Нотация {\bfseries\cf\sharpsign\backwhack{}newline} сохранена с целью обратной совместимости. Её
  использование устарело; вместо неё должна использоваться
  {\bfseries\cf\sharpsign\backwhack{}linefeed}.
\end{note}

%\subsection{Strings}
\subsection{Строки}

%\vest String are represented by sequences of characters enclosed within doublequotes
%({\cf "}).  Within a string literal, various escape
%sequences\mainindex{escape sequence} represent characters other than
%themselves.  Escape sequences always start with a backslash (\backwhack{}):
\vest Строка представляет собой последовательность символов, окружённых двойными кавычками
({\bfseries\cf "}). Внутри стрового литерала различные управляющие
последовательности\mainindex{escape sequence} представляют собой символы, отличные от них
самих. Управляющие последовательности всегда начинаются с обратного слеша
({\bfseries\backwhack{}}):

\begin{itemize}
\item{\bfseries\cf\backwhack{}a} : alarm, U+0007
\item{\bfseries\cf\backwhack{}b} : backspace, U+0008
\item{\bfseries\cf\backwhack{}t} : character tabulation, U+0009
\item{\bfseries\cf\backwhack{}n} : linefeed, U+000A
\item{\bfseries\cf\backwhack{}v} : line tabulation, U+000B
\item{\bfseries\cf\backwhack{}f} : formfeed, U+000C
\item{\bfseries\cf\backwhack{}r} : return, U+000D
\item{\bfseries\cf\backwhack{}}\verb|"| : doublequote, U+0022
\item{\bfseries\cf\backwhack{}\backwhack{}} : backslash, U+005C
\item{\bfseries\cf\backwhack{}}\hyper{intraline whitespace}\hyper{line ending}\\\hspace*{2em}\hyper{intraline whitespace} : nothing
\item{{\bfseries\cf\backwhack{}x}\meta{hex scalar value};} : specified character (note the
  terminating semi-colon).
\end{itemize}

%These escape sequences are case-sensitive, except that the alphabetic
%digits of a \meta{hex scalar value} can be uppercase or lowercase.
Эти управляющие последовательности регистрочувствительны, с одним исключением -- алфавитные
цифры \meta{hex scalar value} могут быть заглавными или строчными.

%Any other character in a string after a backslash is a syntax violation. Except
%for a line ending, any
%character outside of an escape sequence and not a doublequote stands
%for itself in the string literal. For example the single-character
%string literal {\tt "$\lambda$"} (doublequote, a lower case lambda, doublequote)
%represents the same string as {\tt "\backwhack{}x03bb;"}.
%A line ending that does not follow a backslash stands for a linefeed character.
Любой другой символ в строке после обратного слеша является нарушением синтаксиса. За
исключением окончания строки, любой символ в строковом литерале вне управляющей
последовательностии, не являющийся двойными кавычками, обозначает самого себя. Например,
односимвольный строковый литерал {\tt\bfseries "$\lambda$"} (двойные кавычки, строчная lambda, двойные
кавычки) представляет собой ту же строку, что и {\tt\bfseries "\backwhack{}x03bb;"}. Окончание строки,
находящееся не после обратного слеша, обозначает символ перевода строки.

%Examples:
Примеры:

\texonly
\begin{tabbing}
{\cf "\backwhack{}x0000000000;"} \=\kill
\endtexonly
\htmlonly
\begin{tabular}{ll}
\endhtmlonly
{\bfseries\cf "abc"} \extab  \textrm{U+0061, U+0062, U+0063}\\
{\bfseries\cf "\backwhack{}x41;bc"} \extab  {\bfseries\cf "Abc"} ; \textrm{U+0041, U+0062, U+0063}\\
{\bfseries\cf "\backwhack{}x41; bc"} \extab {\bfseries\cf "A bc"}\\
 \extab U+0041, U+0020, U+0062, U+0063\\
{\bfseries\cf "\backwhack{}x41bc;"} \extab  \textrm{U+41BC}\\
{\bfseries\cf "\backwhack{}x41"} \extab \exception{\bfseries\&lexical}\\
{\bfseries\cf "\backwhack{}x;"} \extab \exception{\bfseries\&lexical}\\
{\bfseries\cf "\backwhack{}x41bx;"} \extab \exception{\bfseries\&lexical}\\
{\bfseries\cf "\backwhack{}x00000041;"} \extab  {\bfseries\cf "A"} ; \textrm{U+0041}\\
{\bfseries\cf "\backwhack{}x0010FFFF;"} \extab \textrm{U+10FFFF}\\
{\bfseries\cf "\backwhack{}x00110000;"} \extab  \exception{\bfseries\&lexical}\\
 \extab out of range\\
{\bfseries\cf "\backwhack{}x000000001;"} \extab \textrm{U+0001}\\
{\bfseries\cf "\backwhack{}xD800;"} \extab \exception{\bfseries\&lexical}\\
 \extab in excluded range\\
{\bfseries\cf "A}\\
{\bfseries\cf bc"} \extab \textrm{U+0041, U+000A, U+0062, U+0063}\\
 \extab if no space occurs after the {\bfseries\cf{}A}
\htmlonly
\end{tabular}
\endhtmlonly
\texonly
\end{tabbing}
\endtexonly

%\subsection{Numbers}
\subsection{Числа}
\label{numbernotations}

%The syntax of external representations for number objects is described
%formally by the \meta{number} rule in the formal grammar.
%Case is not significant in external representations of number objects.
Синтаксис внешних представлений числовых объектов формально описывается правилом \meta{number}
формальной грамматики. Во внешних представлениях числовых объектов регистр является незначащим.

%A representation of a number object may be written in binary, octal, decimal, or
%hexadecimal by the use of a radix prefix.  The radix prefixes are {\cf
%\#b}\sharpindex{b} (binary), {\cf \#o}\sharpindex{o} (octal), {\cf
%\#d}\sharpindex{d} (decimal), and {\cf \#x}\sharpindex{x} (hexadecimal).  With
%no radix prefix, a representation of a number object is assumed to be expressed in decimal.
Представление числового объекта может быть записано в двоичном, восьмеричном, десятичном или
шестнадцатеричном виде при помощи приставки основания. Приставками основания являются
{\bfseries\cf \#b}\sharpindex{b} (двоичная), {\bfseries\cf \#o}\sharpindex{o} (восьмеричная),
{\bfseries\cf \#d}\sharpindex{d} (десятичная) и {\bfseries\cf \#x}\sharpindex{x}
(шестнадцатеричная). При отсутствии приставки основания представление числового объекта
полагается десятичным.

%A representation of a number object may be specified to be either exact or
%inexact by a prefix.  The prefixes are {\cf \#e}\sharpindex{e}
%for exact, and {\cf \#i}\sharpindex{i} for inexact.  An exactness
%prefix may appear before or after any radix prefix that is used.  If
%the representation of a number object has no exactness prefix, the
%constant is
%inexact if it contains a decimal point, an
%exponent, or
%a nonempty mantissa width;
%otherwise it is exact.
Представление числового объекта может указываться точным или неточным с помощью
приставки. Приставками являются {\bfseries\cf \#e}\sharpindex{e} в случае точного, и {\bfseries\cf
  \#i}\sharpindex{i} в случае неточного представления. Приставка точности может находиться до
или после любой используемой приставки основания. При отсутствии в представлении числового объекта
приставки точности, константа является неточной, если она содержит десятичную точку, экспоненту или
непустую ширину мантиссы; в противном случае она является точной.

%In systems with inexact number objects
%of varying precisions, it may be useful to specify
%the precision of a constant.  For this purpose, representations of
%number objects
%may be written with an exponent marker that indicates the
%desired precision of the inexact
%representation.  The letters {\cf s}, {\cf f},
%{\cf d}, and {\cf l} specify the use of \var{short}, \var{single},
%\var{double}, and \var{long} precision, respectively.  (When fewer
%than four internal
%inexact
%representations exist, the four size
%specifications are mapped onto those available.  For example, an
%implementation with two internal representations may map short and
%single together and long and double together.)  In addition, the
%exponent marker {\cf e} specifies the default precision for the
%implementation.  The default precision has at least as much precision
%as \var{double}, but
%implementations may wish to allow this default to be set by the user.
В системах с неточными числовыми объектами переменной точности может применяться спецификация
точности константы. Для этого представления числовых объектов могут записываться с
экспоненциальным маркером, задающим желаемую точность неточного представления. Буквы
{\bfseries\cf s}, {\bfseries\cf f}, {\bfseries\cf d} и {\bfseries\cf l} специфицируют использование
точности \var{short}, \var{single}, \var {double} и \var{long} соответственно. (При наличии
менее четырёх внутренних неточных представлений четыре спецификации размера преобразовываются в
доступные. Например, реализация с двумя внутренними представлениями может совместно преобразовывать
данные short и single, а также long и double) Кроме того, экспоненциальный маркер
{\bfseries\cf e} указывает точность реализации по умолчанию. Точность по умолчанию имеет
значение не менее точности \var{double}, но реализации могут разрешать пользователю
устанавливать данное значение по умолчанию.

\begin{scheme}
\bfseries 3.1415926535898F0
       {\rm{}Round to single, perhaps} {\bfseries 3.141593}
\bfseries 0.6L0
       {\rm{}Extend to long, perhaps} {\bfseries .600000000000000}%
\end{scheme}

%A representation of a number object with nonempty mantissa width,
%{\cf \var{x}|\var{p}}, represents the best binary
%floating-point approximation of \var{x} using a \var{p}-bit significand.
%For example, {\cf 1.1|53} is a
%representation of the best approximation of 1.1 in IEEE double
%precision.
%If \var{x} is an external representation of an inexact real number object
%that contains no vertical bar, then its numerical value should be computed
%as though it had a mantissa width of 53 or more.
Представление числового объекта с непустой шириной мантиссы {\cf \var{x}|\var{p}} представляет
собой наилучшую двоичную аппроксимацию плавающей точки \var{x} с помощью \var{p}-битной значащей
части. Например, {\cf\bfseries 1.1|53} является представлением наилучшей аппроксимации 1.1 в
IEEE двойной точности. Если \var{x} является внешним представлением неточного действительного
числового объекта, не содержащим вертикальной черты, его численное значение должно вычисляться
так, как если бы оно имело ширину мантиссы 53 или более.

%Implementations that use binary floating-point representations
%of real number objects should represent {\cf \var{x}|\var{p}}
%using a \var{p}-bit significand if practical, or by a greater
%precision if a \var{p}-bit significand is not practical, or
%by the largest available precision if \var{p} or more bits
%of significand are not practical within the implementation.
Реализации, использующие двоичные представления с плавающей точкой действительных числовых
объектов, должны представлять {\cf \var{x}|\var{p}} с помощью \var{p}-битной значащей части,
если это удобно, или с большей точностью, если \var{p}-битная значащая часть не
удобна, или с наибольшей доступной точностью, если \var{p} или более бит
значащей части не удобны в реализации.

\begin{note}
%The precision of a significand should not be confused with the
%number of bits used to represent the significand.  In the IEEE
%floating-point standards, for example, the significand's most
%significant bit is implicit in single and double precision but
%is explicit in extended precision.  Whether that bit is implicit
%or explicit does not affect the mathematical precision.
%In implementations that use binary floating point, the default
%precision can be calculated by calling the following procedure:
Точность значащей части не следует путать с количеством бит, используемых для представления
значащей части. В стандартах IEEE с плавающей точкой, например, старший значащий бит значащей
части является неявным при одинарной и двойной точности, и явным при расширенной точности. На
математическую точность не влияет, является ли этот бит явным или неявным. В реализациях,
использующих двоичную плавающую точку, точность по умолчанию может быть вычислена путём вызова
следующей процедуры:

\begin{scheme}
\bfseries (define (precision)
\bfseries   (do ((n 0 (+ n 1))
\bfseries        (x 1.0 (/ x 2.0)))
\bfseries     ((= 1.0 (+ 1.0 x)) n)))
\end{scheme}
\end{note}

\begin{note}
%When the underlying floating-point representation is IEEE double
%precision, the {\cf |\var{p}} suffix should not always be omitted:
%Denormalized floating-point numbers have diminished precision,
%and therefore their external representations should
%carry a {\cf |\var{p}} suffix with the actual width of the
%significand.
Если основным представлением плавающей точки является двойная точность IEEE, суффикс {\cf |\var{p}}
не обязан всегда пропускаться: Денормализованные числа с плавающей точкой имеют пониженную
точность, и поэтому их внешние представления должны содержать суффикс {\cf |\var{p}} с
фактической шириной значащей части.
\end{note}

%The literals {\cf +inf.0} and {\cf -inf.0} represent positive and
%negative infinity, respectively.  The {\cf +nan.0}
%literal represents the NaN that is the result of {\cf (/ 0.0 0.0)},
%and may represent other NaNs as well.
Литералы {\cf\bfseries +inf.0} и {\cf\bfseries -inf.0} представляют положительную и
отрицательную бесконечность соответственно. Литерал {\cf\bfseries +nan.0} представляет не число,
являющееся результатом {\cf\bfseries(/ 0.0 0.0)}, и может также представлять другие не числа.

%If \var{x} is an external representation of an inexact real number
%object and
%contains no vertical bar and no exponent marker
%other than {\cf e}, the inexact real number object it represents is a flonum
%(see library section~\extref{lib:flonumssection}{Flonums}).
%Some or all of the other external representations of
%inexact real number objects may also represent flonums, but that is not required by
%this report.
Если \var{x} является внешним представлением неточного действительного числового объекта, а
также не содержит вертикальной черты и иного экспоненциального маркера, нежели {\cf\bfseries e},
неточным действительным числовым объектом, представляющим его, является flonum (см. библиотечную
секцию~\extref{lib:flonumssection}{Flonums}). Некоторые или все другие внешние представления
неточных действительных числовых объектов также могут представлять flonum, но это не является
требованием данного стандарта.

%\section{Datum syntax}
\section{Datum-синтаксис}
\label{datumsyntaxsection}

%The datum syntax describes the syntax of
%syntactic data\mainindex{syntactic datum} in terms of a sequence of
%\meta{lexeme}s, as defined in the lexical syntax.
Datum-синтаксис описывает синтаксис синтаксических данных\mainindex{syntactic datum}
в терминах последовательности \meta{lexeme}, как определено в лексическом
синтаксисе.

%Syntactic data include the lexeme data described in the
%previous section as well as the following constructs for forming
%compound data:
Синтаксические данные включают данные лексем, описанные в предыдущих секциях, а также
следующие конструкции для формирования составных данных:
%
\begin{itemize}
%\item pairs and lists, enclosed by \verb|( )| or \verb|[ ]| (see
%  section~\ref{pairlistsyntax})
\item пары и списки, заключённые в {\bfseries\verb|( )|} или {\bfseries\verb|[ ]|} (см.
  секцию~\ref{pairlistsyntax})
%\item vectors (see section~\ref{vectorsyntax})
\item векторы (см. секцию~\ref{vectorsyntax})
%\item bytevectors (see section~\ref{bytevectorsyntax})
\item байтовые векторы (см. секцию~\ref{bytevectorsyntax})
\end{itemize}

%\subsection{Formal account}
\subsection{Формальное описание}
\label{datumsyntax}

%The following grammar describes the syntax of syntactic data in terms
%of various kinds of lexemes defined in the grammar in
%section~\ref{lexicalsyntaxsection}:
Следующая грамматика описывает синтаксис синтаксических данных в терминах лексем различных видов,
определённых в грамматике в секции ~\ref{lexicalsyntaxsection}:

{%
\renewcommand{\baselinestretch}{1.05}
\selectfont
\begin{grammar}%
\meta{datum} \: \meta{lexeme datum}
\>  \| \meta{compound datum}
\meta{lexeme datum} \: \meta{boolean} \| \meta{number}
\>  \| \meta{character} \| \meta{string} \|  \meta{symbol}
\meta{symbol} \: \meta{identifier}
\meta{compound datum} \: \meta{list} \| \meta{vector} \| \meta{bytevector}
\meta{list} \: \textbf{(}\arbno{\meta{datum}}\textbf{)} \| \textbf{[}\arbno{\meta{datum}}\textbf{]}
\>    \| \textbf{(}\atleastone{\meta{datum}} .\ \meta{datum}\textbf{)} \| \textbf{[}\atleastone{\meta{datum}} .\ \meta{datum}\textbf{]}
\>    \| \meta{abbreviation}
\meta{abbreviation} \: \meta{abbrev prefix} \meta{datum}
\meta{abbrev prefix} \: \textbf{'} \| \textbf{`} \| \textbf{,} \| \textbf{,@}
\>    \| \textbf{\#'} | \textbf{\#`} | \textbf{\#,} | \textbf{\#,@}
\meta{vector} \: \textbf{\#(}\arbno{\meta{datum}}\textbf{)}
\meta{bytevector} \: \textbf{\#vu8(}\arbno{\meta{u8}}\textbf{)}
\meta{u8} \: $\langle${\rm any \meta{number} representing an exact}
 \>\>\quad\quad {\rm integer in $\{0, \ldots, 255\}$}$\rangle$%
\end{grammar}

}

%\subsection{Pairs and lists}
\subsection{Пары и списки}
\label{pairlistsyntax}

%List and pair data, representing pairs and lists of values
%(see section~\ref{listsection}) are represented using parentheses or brackets.
%Matching pairs of brackets that occur in the rules of \meta{list} are
%equivalent to matching pairs of parentheses.
Данные списков и пар, представляющие значения пар и списков (см. секцию~\ref{listsection}),
представляются с помощью круглых или квадратных скобок. Соответствие пар квадратных скобок,
находящихся в правилах \meta{list}, эквивалентно соответствию пар круглых
скобок.

%\newpage

%The most general notation for Scheme pairs as syntactic data is
%the ``dotted'' notation \hbox{\cf (\hyperi{datum} .\ \hyperii{datum})} where
%\hyperi{datum} is the representation of the value of the car field and
%\hyperii{datum} is the representation of the value of the
%cdr field.  For example {\cf (4 .\ 5)} is a pair whose car is 4 and whose
%cdr is 5.
Наиболее общей нотацией для пар Scheme как синтаксических данных является ``точечная'' нотация
\hbox{\cf (\hyperi{datum} .\ \hyperii{datum})}, где \hyperi{datum} является представлением
значения поля car, а \hyperii{datum} -- значения поля cdr. Например, {\cf\bfseries (4 .\ 5)} является
парой, car которой -- 4, а cdr -- 5.

%A more streamlined notation can be used for lists: the elements of the
%list are simply enclosed in parentheses and separated by spaces.  The
%empty list\index{empty list} is represented by {\tt()} .  For example,
Для списков может использоваться упрощённая нотация: элементы списка просто заключаются в
круглые скобки и разделяются пробелами. Пустой список\index{empty list} представляется, как
{\bfseries\tt()}. Например,

\begin{scheme}
\bfseries(a b c d e)%
\end{scheme}

%and
и

\begin{scheme}
\bfseries (a . (b . (c . (d . (e . ())))))%
\end{scheme}

%are equivalent notations for a list of symbols.
являются эквивалентными формами записи списка символов.

%The general rule is that, if a dot is followed by an open parenthesis,
%the dot, open parenthesis, and matching closing parenthesis
%can be omitted in the external representation.
Согласно общему правилу, если за точкой следует открывающая круглая скобка, то точка,
открывающая круглая скобка и соответствующая ей закрывающая круглая скобка во внешнем
представлении могут быть пропущены.

%The sequence of characters ``{\cf (4 .\ 5)}'' is the external representation of a
%pair, not an expression that evaluates to a pair.
%Similarly, the sequence of characters ``{\tt(+ 2 6)}'' is {\em not} an
%external representation of the integer 8, even though it {\em is} an
%expression (in the language of the \rsixlibrary{base} library)
%evaluating to the integer 8; rather, it is a
%syntactic datum representing a three-element list, the elements of which
%are the symbol {\tt +} and the integers 2 and 6.
Последовательность символов ``{\cf\bfseries (4 .\ 5)}'' является внешним представлением пары, а не
выражением, которое вычисляется как пара. Аналогично, последовательность символов ``{\tt\bfseries (+ 2 6)}''
{\em не} является внешним представлением целого числа 8, даже при том, что она {\em является} выраженим
(на языке библиотеки {\bfseries\rsixlibrary{base}}), вычисляемым как целое число 8; напротив, это
синтаксический datum, представляющий трёхэлементный список, элементами которого являются
символ {\tt\bfseries +} и целые числа 2 и 6.

%\subsection{Vectors}
\subsection{Векторы}
\label{vectorsyntax}

%Vector data, representing vectors of objects (see
%section~\ref{vectorsection}), are represented using the notation
%{\tt\#(\hyper{datum} \dotsfoo)}.  For example, a vector of length 3
%containing the number object for zero in element 0, the list {\cf(2 2 2 2)} in
%element 1, and the string {\cf "Anna"} in element 2 can be represented as
%follows:
Данные векторов, представляюшие вектора объектов (см. секцию~\ref{vectorsection}),
представляются с помощью нотации {\tt{\bfseries\#(}\hyper{datum}
  \dotsfoo{\bfseries)}}. Например, вектор с длиной 3, содержащий числовой объект для нуля в
элементе 0, список {\cf\bfseries (2 2 2 2)} в элементе 1 и строку {\cf\bfseries "Anna"} в
элементе 2, может быть представлен следующим образом:

\begin{scheme}
\bfseries \#(0 (2 2 2 2) "Anna")%
\end{scheme}

%This is the external representation of a vector, not an
%expression that evaluates to a vector.
Это внешнее представление вектора, а не выражение, вычисляемое как вектор.

%\subsection{Bytevectors}
\subsection{Байтовые векторы}
\label{bytevectorsyntax}

%Bytevector data, representing bytevectors (see
%library chapter~\extref{lib:bytevectorschapter}{Bytevectors}), are represented using the notation
%{\tt\#vu8(\hyper{u8} \dotsfoo)}, where the \hyper{u8}s represent the octets of
%the bytevector.  For example, a bytevector of length 3 containing the
%octets 2, 24, and 123 can be represented as follows:
Данные байтовых векторов, представляющие байтовые вектора (см. библиотечную
главу~\extref{lib:bytevectorschapter}{Bytevectors}), представляются с помощью нотации
{\tt{\bfseries\#vu8(}\hyper{u8} \dotsfoo{\bfseries )}}, где \hyper{u8} представляет октет
байтового вектора. Например, байтовый вектор с длиной 3, содержащий октеты 2, 24 и 123, может быть
представлен следующим образом:

\begin{scheme}
\bfseries \#vu8(2 24 123)%
\end{scheme}

%This is the external representation of a bytevector, and also an
%expression that evaluates to a bytevector.
Это внешнее представление байтового вектора, а не выражение, вычисляемое как байтовый вектор.

%\subsection{Abbreviations}\unsection
\subsection{Сокращения}\unsection
\label{abbreviationsection}

{%
\renewcommand{\baselinestretch}{1.05}
\selectfont
\begin{entry}{%
\pproto{\textbf{\singlequote}\hyper{datum}}{}
\pproto{\textbf{\backquote}\hyper{datum}}{}
\pproto{\textbf{,}\hyper{datum}}{}
\pproto{\textbf{,\atsign}\hyper{datum}}{}
\pproto{\textbf{\#'}\hyper{datum}}{}
\pproto{\textbf{\#\backquote}\hyper{datum}}{}
\pproto{\textbf{\#,}\hyper{datum}}{}
\pproto{\textbf{\#,@}\hyper{datum}}{}
}\vspace{-1mm}

%Each of these is an abbreviation:
Каждый из них является сокращением:
%\\\quad\schindex{'}\singlequote\hyper{datum}
%for {\cf (quote \hyper{datum})},
%\\\quad\schindex{`}\backquote\hyper{datum}
%for {\cf (quasiquote \hyper{datum})},
%\\\quad\schindex{,}{\cf,}\hyper{datum}
%for {\cf (unquote \hyper{datum})},
%\\\quad\index{,@\texttt{,\atsign}}{\cf,}\atsign\hyper{datum}
%for {\cf (unquote-splicing \hyper{datum})},
%\\\quad\sharpindex{'}{\cf\#'}\hyper{datum}
%for {\cf (syntax \hyper{datum})},
%\\\quad\sharpindex{`}{\cf\#`}\hyper{datum}
%for {\cf (quasisyntax \hyper{datum})},
%\\\quad\sharpindex{,}{\cf\#,}\hyper{datum}
%for {\cf (unsyntax \hyper{datum})}, and
%\\\quad\index{#,@\texttt{\#,\atsign}}{\cf\#,@}\hyper{datum}
%for {\cf (unsyntax-splicing \hyper{datum})}.
\\\quad\schindex{'}{\bfseries\singlequote}\hyper{datum}
для {\cf \textbf{(quote} \hyper{datum}\textbf{)}},
\\\quad\schindex{`}{\bfseries\backquote}\hyper{datum}
для {\cf \textbf{(quasiquote} \hyper{datum}\textbf{)}},
\\\quad\schindex{\bfseries ,}{\cf\bfseries ,}\hyper{datum}
для {\cf \textbf{(unquote} \hyper{datum}\textbf{)}},
\\\quad\index{,@\texttt{,\atsign}}{\cf,}{\bfseries\atsign}\hyper{datum}
для {\cf \textbf{(unquote-splicing} \hyper{datum}\textbf{)}},
\\\quad\sharpindex{'}{\bfseries\cf\#'}\hyper{datum}
для {\cf \textbf{(syntax} \hyper{datum}\textbf{)}},
\\\quad\sharpindex{`}{\bfseries\cf\#`}\hyper{datum}
для {\cf \textbf{(quasisyntax} \hyper{datum}\textbf{)}},
\\\quad\sharpindex{,}{\bfseries\cf\#,}\hyper{datum}
для {\cf \textbf{(unsyntax} \hyper{datum}\textbf{)}}, and
\\\quad\index{#,@\texttt{\#,\atsign}}{\bfseries\cf\#,@}\hyper{datum}
для {\cf \textbf{(unsyntax-splicing} \hyper{datum}\textbf{)}}.
\end{entry}\vspace{-1mm}

}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End:
