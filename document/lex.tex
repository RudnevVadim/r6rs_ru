% Lexical structure
\hyphenation{white-space}
%%\vfill\eject
%\chapter{Lexical syntax and datum syntax}
\chapter{Лексический и datum-синтаксис}
\label{readsyntaxchapter}

%The syntax of Scheme code is organized in three levels:
Синтаксис кода Scheme организован на трёх уровнях:\vspace{-3mm}
%
\begin{enumerate}
%\item the \textit{lexical syntax} that describes how a program text is split
%  into a sequence of lexemes,
\item \textit{Лексический синтаксис}, описывающий, как текст программы разбивается на
  последовательность лексем,
%\item the \textit{datum syntax}, formulated in terms of the lexical
%  syntax, that structures the lexeme sequence as a sequence of
%  \textit{syntactic data\mainindex{datum}\mainindex{syntactic
%      datum}}, where a syntactic datum is
%    a recursively structured entity,
\item \textit{Datum-синтаксис}, сформулированный в терминах лексического синтаксиса,
структурирующий последовательность лексем в виде последовательности \textit{синтаксических
  данных\mainindex{datum}\mainindex{syntactic datum}}, где
синтаксический datum является рекурсивно структурированным элементом,
%\item the \textit{program syntax} formulated in terms of the read
%  syntax, imposing further structure and assigning meaning to
%  syntactic data.
\item \textit{Программный синтаксис}, сформулированный в терминах синтаксиса считывания, задающий
  дальнейшую структуру и наполняющий смысловым содержанием синтаксические данные.
\end{enumerate}\vspace{-3mm}
%
%Syntactic data (also called \textit{external
%  representations\index{external representation}}) double
%as a notation for objects, and Scheme's \rsixlibrary{io ports} library
%(library section~\extref{lib:portsiosection}{Port I/O})
%provides the {\cf get-datum} and {\cf put-datum} procedures
%for reading and writing syntactic data, converting between their
%textual representation and the corresponding objects.
%Each syntactic datum represents a corresponding \defining{datum value}.
%A syntactic datum can be used in a program to obtain the corresponding
%datum value using {\cf quote} (see section~\ref{quote}).
Синтаксические данные (называемые также \textit{внешними представлениями\index{external
    representation}}) одновременно служат как формой записи объектов, так и библиотекой Scheme
{\bfseries\rsixlibrary{io ports}} (секция библиотек~\extref{lib:portsiosection}{Port I/O}),
предоставляющей процедуры {\cf\bfseries get-datum} и {\cf\bfseries put-datum} для чтения и
записи синтаксических данных, преобразовывающие их из текстового представления в
соответствующие объекты, и наоборот. Каждый синтаксический datum представляет соответствующее
\defining{datum-значение}. Синтаксический datum может использоваться в программе для
получения соответствующего datum-значения с помощью {\cf\bfseries quote}
(см. секцию~\ref{quote}).

%Scheme source code consists of syntactic data and (non-significant) comments.
%Syntactic data in Scheme source code are called
%\textit{forms}\mainindex{form}.
%(A form nested inside another form is
%called a \defining{subform}.)
%Consequently, Scheme's syntax has the property that any sequence of
%characters that is a form is also a syntactic datum representing
%some object.  This can lead to confusion, since it may not be obvious
%out of context whether a given sequence of characters is intended to
%be a representation of objects or the text of a program.
%It is also a source of power, since it
%facilitates writing programs such as interpreters or compilers that
%treat programs as objects (or vice versa).
Исходный текст Scheme состоит из синтаксических данных и (незначащих)
комментариев. Синтаксические данные в исходном тексте Scheme называются
\textit{формами}\mainindex{form}. (Форма, вложенная в другую форму, называется
\defining{подформой}.) Следовательно, синтаксис Scheme обладает свойством, что любая
последовательность символов, являющаяся формой, является также и синтаксическим datum,
представляющей некоторый объект. Это может привести к замешательству, так как из контекста может
быть не ясно, предназначена ли данная последовательность символов для представления объектов или
текста программы. Это - также источник мощи, так как это облегчает написание программ,
типа интерпретаторов или компиляторов, интерпретирующих программы в качестве объектов (или наоборот).

%A datum value may have several different external representations.
%For example, both ``{\tt \#e28.000}'' and
%``{\tt\#x1c}'' are syntactic data representing the exact integer
%object 28, and the syntactic data ``{\tt(8 13)}'', ``{\tt( 08 13 )}'', ``{\tt(8 .\
%  (13 .\ ()))}''
%all represent a list containing the exact integer objects 8 and 13.
%Syntactic data that represent equal objects (in the sense of {\cf
%  equal?}; see section~\ref{equal?}) are always equivalent
%as forms of a program.
Datum-значение может иметь несколько разных внешних представлений. Например, и ``{\tt\bfseries
  \#e28.000}'', и ``{\tt\bfseries\#x1c}'' являются синтаксическими данными, представляющими
точный целый объект 28, а синтаксические данные ``{\tt\bfseries(8 13)}'', ``{\tt\bfseries( 08 13
  )}'', ``{\tt\bfseries(8 .\ (13 .\ ()))}'' представляют список, содержащий точные целые
объекты 8 и 13. Синтаксические данные, представляющие равные объекты (в смысле {\cf\bfseries
  equal?}; см. секцию~\ref{equal?}), всегда эквивалентны как формы программы.

%Because of the close correspondence between syntactic data and datum
%values, this report sometimes uses the term \defining{datum} for
%either a syntactic datum or a datum value when the exact meaning
%is apparent from the context.
Вследствие точного соответствия синтаксических данных и datum-значений в данной работе термин
\defining{datum} иногда используется и для синтаксического datum, и для datum-значения, когда
точный смысл очевиден из контекста.

%An implementation must not extend the lexical or datum syntax in
%any way, with one exception: it need not treat the syntax
%{\cf \sharpsign{}!\meta{identifier}}, for any \meta{identifier} (see
%section~\ref{identifiersection}) that is not {\cf r6rs}, as a syntax
%violation, and it may use specific {\cf \sharpsign{}!}-prefixed
%identifiers as flags indicating that subsequent input contains extensions
%to the standard lexical or datum syntax.
%The syntax {\cf \sharpsign{}!r6rs} may be used to signify that
%the input afterward is written with the lexical syntax and
%datum syntax described by
%this report.
%{\cf \sharpsign{}!r6rs} is otherwise treated as a comment; see section~\ref{whitespaceandcomments}.
Реализация никогда не должна расширять лексический или datum-синтаксис, за
одним исключением: она не должна интерпретировать синтаксис {\cf{\bfseries \sharpsign{}!}\meta
  {identifier}}, для любого \meta{identifier} (см. секцию~\ref {identifiersection}),
который не {\cf\bfseries r6rs}, как нарушение синтаксиса, и она может использовать специфические
{\cf\bfseries \sharpsign {}!}-prefixed идентификаторы как флаги, указывающие, что последующий
вход содержит расширения к лексическому стандарту или datum-синтаксису. Синтаксис {\cf \sharpsign
\bfseries{}!r6rs} может использоваться, чтобы показать, что вход позже написан с лексическим и
datum-синтаксисом, описанным в данной работе. {\cf \sharpsign\bfseries {}!r6rs} иначе интерпретируется
как комментарий; см. секцию~\ref {whitespaceandcomments}.

%\section{Notation}
\section{Нотация}
\label{BNF}

%The formal syntax for Scheme is written in an extended BNF.
%Non-terminals are written using angle brackets.  Case is insignificant
%for non-terminal names.
Формальный синтаксис Scheme записан в расширенном BNF. Нетерминальные символы записаны с помощью
угловых скобок. Регистр является незначащим для нетерминальных имён.

%All spaces in the grammar are for legibility.
%\meta{Empty} stands for the empty string.
Все пробелы в грамматике применяются для удобочитаемости. \meta{Empty} обозначает пустую строку.

%The following extensions to BNF are used to make the description more
%concise:  \arbno{\meta{thing}} means zero or more occurrences of
%\meta{thing}, and \atleastone{\meta{thing}} means at least one
%\meta{thing}.
Для более краткого описания используются следующие расширения BNF: \arbno{\meta{thing}} означает
ноль или больше возникновений \meta{thing}, а \atleastone{\meta{thing}} означает по крайней мере
один \meta{thing}.

%Some non-terminal names refer to the Unicode scalar values of the same
%name: \meta{character tabulation} (U+0009), \meta{linefeed} (U+000A),
%\meta{carriage return} (U+000D), \meta{line tabulation} (U+000B),
%\meta{form feed} (U+000C), \meta{carriage return} (U+000D),
%\meta{space} (U+0020), \meta{next line} (U+0085), \meta{line
%  separator} (U+2028), and \meta{paragraph separator} (U+2029).
Некоторые нетерминальные имена относятся к скалярным значениям Unicode того же самого имени:
\meta{character tabulation} (U+0009), \meta{linefeed} (U+000A), \meta{carriage return} (U+000D),
\meta{line tabulation} (U+000B), \meta{form feed} (U+000C), \meta{carriage return} (U+000D),
\meta{space (U+0020)}, \meta{next line} (U+0085), \meta{line separator} (U+2028) и
\meta{paragraph separator} (U+2029).

%\section{Lexical syntax}
\section{Лексический синтаксис}
\label{lexicalsyntaxsection}

%The lexical syntax determines how a character sequence is split into a
%sequence of lexemes\index{lexeme}, omitting non-significant portions
%such as comments and whitespace.  The character sequence is assumed to
%be text according to the Unicode standard~\cite{Unicode}.  Some of
%the lexemes, such as identifiers, representations of number objects, strings etc., of the lexical
%syntax are syntactic data in the datum syntax, and thus represent objects.
%Besides the formal account of the syntax, this section also describes
%what datum values are represented by these syntactic data.
Лексический синтаксис определяет, как символьная последовательность разбивается на
последовательность лексем\index{lexeme}, пропуская незначащие части, типа комментариев и
пробелов. Полагается, что символьная последовательность является текстом согласно стандарту
Unicode~\cite{Unicode}. Некоторые из лексем, типа идентификаторов, представлений числовых объектов,
строки и т.д., лексического синтаксиса являются синтаксическими данными в datum-синтаксисе
и, таким образом, представляют объекты. Помимо формального описания синтаксиса, в этой
секции также описывается, какие datum-значения представляют эти синтаксические
данные.

%The lexical syntax, in the description of comments, contains
%a forward reference to \meta{datum}, which is described as part of the
%datum syntax.  Being comments, however, these \meta{datum}s do not play
%a significant role in the syntax.
Лексический синтаксис в описании комментариев содержит прямую ссылку на \meta{datum},
описанную как часть datum-синтаксиса. Будучи комментариями, однако,
такие \meta{datum} не играют существенную роль в синтаксисе.

%Case is significant except in representations of booleans, number objects, and
%in hexadecimal numbers specifying Unicode scalar values.  For example, {\cf \#x1A}
%and {\cf \#X1a} are equivalent.  The identifier {\cf Foo} is, however,
%distinct from the identifier {\cf FOO}.
Регистр является значащим, за исключением представлений booleans, числовых объектов и
шестнадцатеричных чисел, определяющих скалярные значения Unicode. Например, {\cf\bfseries \#x1A}
и {\cf\bfseries \#X1a} эквивалентны. А вот идентификатор {\cf\bfseries Foo} отличается от
идентификатора {\cf\bfseries FOO}.

%\subsection{Formal account}
\subsection{Формальное описание}
\label{lexicalgrammarsection}

%\meta{Interlexeme space} may occur on either side of any lexeme, but not
%within a lexeme.
\meta{Interlexeme space} может находиться с любой стороны лексемы, но не внутри лексемы

%\hyper{Identifier}s, {\cf .}, \hyper{number}s, \hyper{character}s, and
%\hyper{boolean}s, must be terminated by a \meta{delimiter} or by the
%end of the input.
\hyper{Identifier}, {\cf .}, \hyper{number}, \hyper{character} и
\hyper{boolean} могут заканчиваться \meta{delimiter} или концом ввода.

%The following two characters are reserved for future extensions to the
%language: {\tt \verb"{" \verb"}"}
Следующие два знака зарезервированы для будущих расширений языка:
{\tt \verb"{" \verb"}"}

\begin{grammar}%
\meta{lexeme} \: \meta{identifier} \| \meta{boolean} \| \meta{number}\index{identifier}
\>  \| \meta{character} \| \meta{string}
\>  \| ( \| ) \| \openbracket{} \| \closedbracket{} \| \sharpsign( \| \sharpsign{}vu8( | \singlequote{} \| \backquote{} \| , \| ,@ \| {\bf.}
\>  \| \sharpsign\singlequote{} \| \sharpsign\backquote{} \| \sharpsign, \| \sharpsign,@
\meta{delimiter} \: ( \| ) \| \openbracket{} \| \closedbracket{} \| " \| ; \| \sharpsign{}
\>  \| \meta{whitespace}
\meta{whitespace} \: \meta{character tabulation}
\> \| \meta{linefeed} \| \meta{line tabulation} \| \meta{form feed}
\> \| \meta{carriage return} \| \meta{next line}
\> \| \meta{any character whose category is Zs, Zl, or Zp}
\meta{line ending} \: \meta{linefeed} \| \meta{carriage return}
\> \| \meta{carriage return} \meta{linefeed} \| \meta{next line}
\> \| \meta{carriage return} \meta{next line} \| \meta{line separator}
\meta{comment} \: ; \= $\langle$\rm all subsequent characters up to a
                    \>\ \rm \meta{line ending} or \meta{paragraph separator}$\rangle$\index{comment}
\qquad \= \| \meta{nested comment}
\> \| \#; \meta{interlexeme space} \meta{datum}
\> \| \#!r6rs
\meta{nested comment} \: \#| \= \meta{comment text}
\> \arbno{\meta{comment cont}} |\#
\meta{comment text} \: \= $\langle$\rm character sequence not containing
\>\ \rm {\tt \#|} or {\tt |\#}$\rangle$
\meta{comment cont} \: \meta{nested comment} \meta{comment text}
\meta{atmosphere} \: \meta{whitespace} \| \meta{comment}
\meta{interlexeme space} \: \arbno{\meta{atmosphere}}%
\end{grammar}

\label{extendedalphas}
\label{identifiersyntax}

% This is a kludge, but \multicolumn doesn't work in tabbing environments.
\setbox0\hbox{\cf\meta{variable} \goesto{} $\langle$}

\begin{grammar}%
\meta{identifier} \: \meta{initial} \arbno{\meta{subsequent}}
 \>  \| \meta{peculiar identifier}
\meta{initial} \: \meta{constituent} \| \meta{special initial}
 \> \| \meta{inline hex escape}
\meta{letter} \:  a \| b \| c \| ... \| z
\> \| A \| B \| C \| ... \| Z
\meta{constituent} \: \meta{letter}
 \> \| $\langle${\rm any character whose Unicode scalar value is greater than}
 \> \quad {\rm 127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,}
 \> \quad {\rm Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co}$\rangle$
\end{grammar}

\newpage

\begin{grammar}
\meta{special initial} \: ! \| \$ \| \% \| \verb"&" \| * \| / \| : \| < \| =
 \>  \| > \| ? \| \verb"^" \| \verb"_" \| \verb"~"
\meta{subsequent} \: \meta{initial} \| \meta{digit}
 \>  \| \meta{any character whose category is Nd, Mc, or Me}
 \>  \| \meta{special subsequent}
\meta{digit} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7 \| 8 \| 9
\meta{hex digit} \: \meta{digit}
 \> \| a \| A \| b \| B \| c \| C \| d \| D \| e \| E \| f \| F
\meta{special subsequent} \: + \| - \| .\ \| @
\meta{inline hex escape} \: \backwhack{}x\meta{hex scalar value};
\meta{hex scalar value} \: \atleastone{\meta{hex digit}}
\meta{peculiar identifier} \: + \| - \| ... \| -> \arbno{\meta{subsequent}}
\meta{boolean} \: \schtrue{} \| \#T \| \schfalse{} \| \#F
\meta{character} \: \#\backwhack{}\meta{any character}
 \>  \| \#\backwhack{}\meta{character name}
 \>  \| \#\backwhack{}x\meta{hex scalar value}
\meta{character name} \: nul \| alarm \| backspace \| tab
\> \| linefeed \| newline \| vtab \| page \| return
\> \| esc \| space \| delete
\meta{string} \: " \arbno{\meta{string element}} "
\meta{string element} \: \meta{any character other than \doublequote{} or \backwhack}
 \> \| \backwhack{}a \| \backwhack{}b \| \backwhack{}t \| \backwhack{}n \| \backwhack{}v \| \backwhack{}f \| \backwhack{}r
 \>  \| \backwhack\doublequote{} \| \backwhack\backwhack
 \>  \| \backwhack\meta{intraline whitespace}\meta{line ending}
 \>  \hspace*{4em}\meta{intraline whitespace}
 \>  \| \meta{inline hex escape}
\meta{intraline whitespace} \: \meta{character tabulation}
\> \| \meta{any character whose category is Zs}%
\end{grammar}

A \meta{hex scalar value} represents a Unicode scalar value
between 0 and \sharpsign{}x10FFFF, excluding the range
$\left[\sharpsign{}x\textrm{D800}, \sharpsign{}x\textrm{DFFF}\right]$.

\label{numbersyntax}%
The rules for \meta{num $R$}, \meta{complex $R$}, \meta{real
$R$}, \meta{ureal $R$}, \meta{uinteger $R$}, and \meta{prefix $R$} below
should be replicated for \hbox{$R = 2, 8, 10,$}
and $16$.  There are no rules for \meta{decimal $2$}, \meta{decimal
$8$}, and \meta{decimal $16$}, which means that number representations containing
decimal points or exponents must be in decimal radix.

\begin{grammar}%
\meta{number} \: \meta{num $2$} \| \meta{num $8$}
   \>  \| \meta{num $10$} \| \meta{num $16$}
\meta{num $R$} \: \meta{prefix $R$} \meta{complex $R$}
\meta{complex $R$} \: %
         \meta{real $R$} %
      \| \meta{real $R$} @ \meta{real $R$}
   \> \| \meta{real $R$} + \meta{ureal $R$} i %
      \| \meta{real $R$} - \meta{ureal $R$} i
   \> \| \meta{real $R$} + \meta{naninf} i %
      \| \meta{real $R$} - \meta{naninf} i
   \> \| \meta{real $R$} + i %
      \| \meta{real $R$} - i
   \> \| + \meta{ureal $R$} i %
      \| - \meta{ureal $R$} i
   \> \| + \meta{naninf} i %
      \| - \meta{naninf} i
   \> \| + i %
      \| - i
\meta{real $R$} \: \meta{sign} \meta{ureal $R$}
  \> \| + \meta{naninf} \| - \meta{naninf}
\meta{naninf} \: nan.0 \| inf.0
\meta{ureal $R$} \: %
         \meta{uinteger $R$}
   \> \| \meta{uinteger $R$} / \meta{uinteger $R$}
   \> \| \meta{decimal $R$} \meta{mantissa width}
\meta{decimal $10$} \: %
         \meta{uinteger $10$} \meta{suffix}
   \> \| . \atleastone{\meta{digit $10$}} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} . \arbno{\meta{digit $10$}} \meta{suffix}
   \> \| \atleastone{\meta{digit $10$}} . \meta{suffix}
\meta{uinteger $R$} \: \atleastone{\meta{digit $R$}}
\meta{prefix $R$} \: %
         \meta{radix $R$} \meta{exactness}
   \> \| \meta{exactness} \meta{radix $R$}
\end{grammar}

\begin{grammar}%
\meta{suffix} \: \meta{empty}
   \> \| \meta{exponent marker} \meta{sign} \atleastone{\meta{digit $10$}}
\meta{exponent marker} \: e \| E \| s \| S \| f \| F
   \> \| d \| D \| l \| L
\meta{mantissa width} \: \meta{empty}
   \> \| | \atleastone{\meta{digit 10}}
\meta{sign} \: \meta{empty}  \| + \|  -
\meta{exactness} \: \meta{empty}
   \> \| \#i\sharpindex{i} \| \#I \| \#e\sharpindex{e} \| \#E
\meta{radix 2} \: \#b\sharpindex{b} \| \#B
\meta{radix 8} \: \#o\sharpindex{o} \| \#O
\meta{radix 10} \: \meta{empty} \| \#d \| \#D
\meta{radix 16} \: \#x\sharpindex{x} \| \#X
\meta{digit 2} \: 0 \| 1
\meta{digit 8} \: 0 \| 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7
\meta{digit 10} \: \meta{digit}
\meta{digit 16} \: \meta{hex digit}
\end{grammar}

%\subsection{Line endings}
\subsection{Окончание строки}
\label{lineendings}

%Line endings are significant in Scheme in single-line comments (see
%section~\ref{whitespaceandcomments}) and within string literals.  In
%Scheme source code, any of the line endings in \meta{line ending}
%marks the end of a line.  Moreover, the two-character line endings
%\meta{carriage return} \meta{linefeed} and \meta{carriage return}
%\meta{next line} each count as a single line ending.
В Scheme окончание строки является значащим в однострочных комментариях (см. секцию~\ref
{whitespaceandcomments}) и внутри строковых литералов. В исходном тексте Scheme любое
окончание строки в \meta{line ending} означает конец строки. Кроме того, двухсимвольное
окончание строки \meta{carriage return} \meta{linefeed} и \meta{carriage return} \meta
{next line} считается одним окончанием строки.

%In a string literal, a \hyper{line ending} not preceded by a {\cf\backwhack}
%stands for a linefeed character, which is the standard line-ending
%character of Scheme.
В строковом литерале \hyper{line ending} без {\cf\backwhack} перед ним обозначает
символ linefeed, являющийся стандартным символом конца строки Scheme.

%\subsection{Whitespace and comments}
\subsection{Пробельные символы и комментарии}
\label{whitespaceandcomments}

%\defining{Whitespace} characters are spaces, linefeeds,
%carriage returns, character tabulations, form feeds, line tabulations,
%and any other character whose category is Zs, Zl, or Zp.
%Whitespace is used for improved readability and
%as necessary to separate lexemes from each other.  Whitespace may
%occur between any two lexemes,
%but not within a lexeme.  Whitespace may also occur inside a string,
%where it is significant.
\defining{Пробельными} символами являются пробелы, обратные переводы строк, переводы каретки, символы
табуляции, переводы страницы, линейные табуляции и любой другой символ, категория которого - Zs,
Zl, или Zp. Пробельные символы используются для улучшения удобочитаемости и при необходимости
отделения лексем друг от друга. Пробельные символы могут находиться между любыми двумя
лексемами, но не внутри лексемы. Пробельный символ может также находиться в строке, где он
является значащим.

%The lexical syntax includes several comment forms. In all cases,
%comments are invisible to Scheme, except that they act as delimiters,
%so, for example, a comment cannot appear in the middle of an
%identifier or representation of a number object.
Лексический синтаксис включает несколько форм комментариев. Во всех случаях, комментарии
невидимы, в Scheme, за исключением того, что они действуют как разделители, таким
образом, например, комментарий не может находиться в середине идентификатора или представления
числового объекта.

\newpage

%A semicolon ({\tt;}) indicates the start of a line
%comment.\mainindex{comment}\mainschindex{;} The comment continues to
%the end of the line on which the semicolon appears.
Точка с запятой ({\tt;}), указывает начало строки комментария.\mainindex{comment}
  \mainschindex{;} Комментарий продолжается до конца строки, на которой находится точка с
запятой.

%Another way to indicate a comment is to prefix a \hyper{datum}
%(cf.\ section~\ref{datumsyntax}) with {\tt \#;}\sharpindex{;}, possibly with
%\meta{interlexeme space} before the \hyper{datum}.  The comment consists of
%the comment prefix {\tt \#;} and the \hyper{datum} together.  This
%notation is useful for ``commenting out'' sections of code.
Другим способом указания комментария является добавления к \hyper{datum} (см.\ секцию~\ref
{datumsyntax}) префикса {\tt\bfseries \#;}\sharpindex{;}, возможно с \meta{interlexeme space} перед
\hyper{datum}. Комментарий состоит из приставки комментария {\tt\bfseries \#;} и \hyper{datum}.
Такая нотация полезна для ``комментирования'' секций кода.

%Block comments may be indicated with properly nested {\tt
%  \#|}\index{#"|@\texttt{\sharpsign\verticalbar}}\index{"|#@\texttt{\verticalbar\sharpsign}}
%and {\tt |\#} pairs.
Блоковые комментарии могут быть обозначены соответствующим образом вложенными парами {\tt\bfseries \#|}
\index{#"|'@\texttt{\sharpsign\verticalbar}}\index{"|#@\texttt{\verticalbar\sharpsign}} и {\tt\bfseries |\#}.

\begin{scheme}
\bfseries\#|
\bfseries   The FACT procedure computes the factorial
\bfseries   of a non-negative integer.
\bfseries|\#
\bfseries(define fact
\bfseries  (lambda (n)
\bfseries    ;; base case
\bfseries    (if (= n 0)
\bfseries        \#;(= n 1)
\bfseries        1       ; identity of *
\bfseries        (* n (fact (- n 1))))))%
\end{scheme}

%The lexeme {\cf \sharpsign{}!r6rs}, which signifies that the program text
%that follows is written with the lexical and datum syntax described in this
%report, is also otherwise treated as a comment.
Лексема {\cf\bfseries \sharpsign{}!r6rs}, которая означает, что текст следующей далее программы
написан с лексическим и data-синтаксисом, описанным в данной работе, также иным образом
интерпретируется как комментарий.

%\subsection{Identifiers}
\subsection{Идентификаторы}
\label{identifiersection}

%Most identifiers\mainindex{identifier} allowed by other programming
%languages are also acceptable to Scheme.  In general,
%a sequence of letters, digits, and ``extended alphabetic
%characters'' is
%an identifier when it begins with a character that cannot begin a
%representation of a number object.
%In addition, \ide{+}, \ide{-}, and \ide{...} are identifiers, as is
%a sequence of letters, digits, and extended alphabetic
%characters that begins with the two-character sequence \ide{->}.
%Here are some examples of identifiers:
Большинство идентификаторов\mainindex{identifier}, допустимых в других языках программирования,
также допустимы и в Scheme. В общем случае, последовательность букв, цифр, и ``расширенных алфавитных
символов'' является идентификатором, если она начинается с символа, с которого не может начинаться
представление числового объекта. Кроме того, идентификаторами являются \ide{+}, \ide{-} и \ide{...},
равно как и последовательность букв, цифр и расширенных алфавитных символов, начинающаяся
с двухсимвольной последовательности \ide{->}. Некоторые примеры идентификаторов:

\begin{scheme}
\bfseries lambda         q                soup
\bfseries list->vector   {+}                V17a
\bfseries <=             a34kTMNs         ->-
\bfseries the-word-recursion-has-many-meanings%
\end{scheme}

%Extended alphabetic characters may be used within identifiers as if
%they were letters.  The following are extended alphabetic characters:
Расширенные алфавитные символы могут использоваться внутри идентификаторов, как если бы они
были буквами. Расширенными алфавитными символами являются:

\begin{scheme}
\bfseries !\ \$ \% \verb"&" * + - . / :\ < = > ? @ \verb"^" \verb"_" \verb"~" %
\end{scheme}

%Moreover, all characters whose Unicode scalar values are greater than 127 and
%whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No, Pd,
%Pc, Po, Sc, Sm, Sk, So, or Co can be used within identifiers.
%In addition, any character can be used within an identifier
%when specified via an \meta{inline hex escape}.  For example, the
%identifier \verb|H\x65;llo| is the same as the identifier
%\verb|Hello|, and the identifier \verb|\x3BB;| is the same as the
%identifier $\lambda$.
Кроме того, в идентификаторах могут использоваться все символы, чьи скалярные значения Unicode
больше, чем 127, и чьей категорией Unicode является Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd, Nl, No,
Pd, Pc, Po, Sc, Sm, Sk, So, или Co. Кроме того, любой символ может использоваться в
идентификаторе, если он специфицирован через \meta{inline hex escape}. Например,
идентификатор \verb|H\x65;llo| - точо такой же, как и идентификатор \verb|Hello|, а идентификатор
\verb|\x3BB;| - точно такой же, как и идентификатор $\lambda$.

%Any identifier may be used as a variable\index{variable} or as a
%syntactic keyword\index{syntactic keyword} (see
%sections~\ref{variablesection} and~\ref{macrosection}) in a Scheme
%program.
%Any identifier may also be used as a syntactic datum, in which case it
%represents a \textit{symbol}\index{symbol} (see section~\ref{symbolsection}).
В программе Scheme любой идентификатор может использоваться как переменная\index{variable} или
как синтаксическое ключевое слово\index {syntactic keyword} (см. секции~\ref{variablesection}
и~\ref{macrosection}) . Любой идентификатор может также использоваться как синтаксический datum,
в этом случае он представляет \textit{символ}\index{symbol} (см. секцию~\ref{symbolsection}).

\subsection{Booleans}

%The standard boolean objects for true and false have external representations
%\schtrue{} and \schfalse.\sharpindex{t}\sharpindex{f}
Стандартные булевые объекты для true и false имеют внешние представления {\bfseries\schtrue{}} и
{\bfseries\schfalse}.\sharpindex{t}\sharpindex{f}

\subsection{Символы}

%Characters are represented using the notation
%\sharpsign\backwhack\hyper{character}\index{#\@\texttt{\sharpsign\backwhack}} or
%\sharpsign\backwhack\hyper{character name} or
%\sharpsign\backwhack{}x\meta{hex scalar value}.
Символы представляются с помощью нотации
{\bfseries\sharpsign\backwhack}\hyper{character}\index{#\@\texttt{\sharpsign\backwhack}} или
{\bfseries\sharpsign\backwhack}\hyper{character name} или
{\bfseries\sharpsign\backwhack{}x}\meta{hex scalar value}.

%For example:
Например:

\texonly
\newcommand{\extab}{\>}
\begin{tabbing}
{\cf\#\backwhack{}x0000000000}\=\kill
\endtexonly
\htmlonly
\newcommand{\extab}{&}
\begin{tabular}{ll}
\endhtmlonly
{\cf\bfseries\#\backwhack{}a}          \extab \textrm{lower case letter a}\\
{\cf\bfseries\#\backwhack{}A}          \extab \textrm{upper case letter A}\\
{\cf\bfseries\#\backwhack{}(}          \extab \textrm{left parenthesis}\\
{\cf\bfseries\#\backwhack{}}           \extab \textrm{space character}\\
{\cf\bfseries\#\backwhack{}nul}        \extab \textrm{U+0000}\\
{\cf\bfseries\#\backwhack{}alarm}      \extab \textrm{U+0007}\\
{\cf\bfseries\#\backwhack{}backspace}  \extab \textrm{U+0008}\\
{\cf\bfseries\#\backwhack{}tab}        \extab \textrm{U+0009}\\
{\cf\bfseries\#\backwhack{}linefeed}   \extab \textrm{U+000A}\\
{\cf\bfseries\#\backwhack{}newline}   \extab \textrm{U+000A}\\
{\cf\bfseries\#\backwhack{}vtab}       \extab \textrm{U+000B}\\
{\cf\bfseries\#\backwhack{}page}       \extab \textrm{U+000C}\\
{\cf\bfseries\#\backwhack{}return}     \extab \textrm{U+000D}\\
{\cf\bfseries\#\backwhack{}esc}        \extab \textrm{U+001B}\\
{\cf\bfseries\#\backwhack{}space}      \extab \textrm{U+0020}\\
 \extab preferred way to write a space\\
{\cf\bfseries\#\backwhack{}delete}     \extab \textrm{U+007F}\\[1ex]
{\cf\bfseries\#\backwhack{}xFF}        \extab \textrm{U+00FF}\\
{\cf\bfseries\#\backwhack{}x03BB}      \extab \textrm{U+03BB}\\
{\cf\bfseries\#\backwhack{}x00006587}  \extab \textrm{U+6587}\\
{\cf\bfseries\#\backwhack{}\(\lambda\)} \extab \textrm{U+03BB}\\[1ex]
{\cf\bfseries\#\backwhack{}x0001z}     \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}\(\lambda\)x}         \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}alarmx}     \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}alarm x}    \extab \textrm{U+0007}\\
 \extab followed by {\cf{}x}\\
{\cf\bfseries\#\backwhack{}Alarm}      \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}alert}      \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}xA}         \extab \textrm{U+000A}\\
{\cf\bfseries\#\backwhack{}xFF}        \extab \textrm{U+00FF}\\
{\cf\bfseries\#\backwhack{}xff}        \extab \textrm{U+00FF}\\
{\cf\bfseries\#\backwhack{}x ff}       \extab \textrm{U+0078}\\
 \extab followed by another datum, {\bfseries\cf{}ff}\\[34mm]
{\cf\bfseries\#\backwhack{}x(ff)}      \extab \textrm{U+0078}\\
 \extab followed by another datum,\\
 \extab a parenthesized {\bfseries\cf{}ff}\\
{\cf\bfseries\#\backwhack{}(x)}        \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}(x}         \extab \exception{\bfseries\&lexical}\\
{\cf\bfseries\#\backwhack{}((x)}       \extab \textrm{U+0028}\\
 \extab followed by another datum,\\
 \extab parenthesized {\bfseries\cf{}x}\\
{\cf\bfseries\#\backwhack{}x00110000}  \extab \exception{\bfseries\&lexical}\\
 \extab out of range\\
{\cf\bfseries\#\backwhack{}x000000001} \extab \textrm{U+0001}  \\
{\cf\bfseries\#\backwhack{}xD800}      \extab \exception{\bfseries\&lexical}\\
 \extab in excluded range
\htmlonly
\end{tabular}
\endhtmlonly
\texonly
\end{tabbing}
\endtexonly

%(The notation \exception{\&lexical} means that the line in question is
%a lexical syntax violation.)
(Примечание \exception{\bfseries\&lexical} означает, что рассматриваемая строка является
лексическим нарушением синтаксиса.)

%Case is significant in \sharpsign\backwhack\hyper{character}, and in
%\sharpsign\backwhack{\rm$\langle$character name$\rangle$}, % \hyper doesn't allow a linebreak
%but not in {\cf\sharpsign\backwhack{}x}\meta{hex scalar value}.
%A \meta{character} must be followed by a \meta{delimiter} or by the end of the input.
%This rule resolves various ambiguous cases involving named characters,
%requiring, for
%example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
%to be interpreted as the space character rather than as
%the character ``{\tt\sharpsign\backwhack s}'' followed
%by the identifier ``{\tt pace}''.
Регистр является значащим в {\bfseries\sharpsign\backwhack}\hyper{character} и в
{\bfseries\sharpsign\backwhack} {\rm$\langle$character name$\rangle$}, но не в
{\bfseries\cf\sharpsign\backwhack{}x}\meta{hex scalar value}. За \meta{character} должен находиться
\meta{delimeter} или конец ввода. Это правило разрешает различные неоднозначные случаи с участием
названных символов, требуя, например, чтобы последовательность символов
``{\bfseries\tt\sharpsign\backwhack space}'' интерпретировалась как символ пробела, а не как символ
``{\bfseries\tt\sharpsign\backwhack s}''и следующим за ним идентификатором ``{\bfseries\tt pace}''.

\begin{note}
  %The {\cf\sharpsign\backwhack{}newline} notation is retained for
  %backward compatibility.  Its use is deprecated;
  %{\cf\sharpsign\backwhack{}linefeed} should be used instead.
  Нотация {\bfseries\cf\sharpsign\backwhack{}newline} сохранена с целью обратной совместимости. Её
  использование устарело; вместо неё должна использоваться
  {\bfseries\cf\sharpsign\backwhack{}linefeed}.
\end{note}

%\subsection{Strings}
\subsection{Строки}

%\vest String are represented by sequences of characters enclosed within doublequotes
%({\cf "}).  Within a string literal, various escape
%sequences\mainindex{escape sequence} represent characters other than
%themselves.  Escape sequences always start with a backslash (\backwhack{}):
\vest Строка представляется последовательностью символов, окружённых двойными кавычками
({\bfseries\cf "}). Внутри стрового литерала различные управляющие последовательности\mainindex
{escape sequence} представляют символы, кроме самих себя. Управляющие последовательности
всегда начинаются с обратного слеша ({\bfseries\backwhack{}}):


\begin{itemize}
\item{\bfseries\cf\backwhack{}a} : alarm, U+0007
\item{\bfseries\cf\backwhack{}b} : backspace, U+0008
\item{\bfseries\cf\backwhack{}t} : character tabulation, U+0009
\item{\bfseries\cf\backwhack{}n} : linefeed, U+000A
\item{\bfseries\cf\backwhack{}v} : line tabulation, U+000B
\item{\bfseries\cf\backwhack{}f} : formfeed, U+000C
\item{\bfseries\cf\backwhack{}r} : return, U+000D
\item{\bfseries\cf\backwhack{}}\verb|"| : doublequote, U+0022
\item{\bfseries\cf\backwhack{}\backwhack{}} : backslash, U+005C
\item{\bfseries\cf\backwhack{}}\hyper{intraline whitespace}\hyper{line ending}\\\hspace*{2em}\hyper{intraline whitespace} : nothing
\item{{\bfseries\cf\backwhack{}x}\meta{hex scalar value};} : specified character (note the
  terminating semi-colon).
\end{itemize}

%These escape sequences are case-sensitive, except that the alphabetic
%digits of a \meta{hex scalar value} can be uppercase or lowercase.
Эти управляющие последовательности регистрочувствительны, за исключением того, что алфавитные
цифры \meta{hex scalar value} могут быть заглавными или строчными.

%Any other character in a string after a backslash is a syntax violation. Except
%for a line ending, any
%character outside of an escape sequence and not a doublequote stands
%for itself in the string literal. For example the single-character
%string literal {\tt "$\lambda$"} (doublequote, a lower case lambda, doublequote)
%represents the same string as {\tt "\backwhack{}x03bb;"}.
%A line ending that does not follow a backslash stands for a linefeed character.
Любой другой символ в строке после обратного слеша является нарушением синтаксиса. За
исключением окончания строки, любой символ в строковом литерале вне управляющей
последовательностии, не являющийся двойными кавычками, обозначает самого себя. Например,
односимвольный строковый литерал {\tt "$\lambda$"} (двойные кавычки, строчная lambda, двойные
кавычки) представляет ту же самую строку, как и {\tt\bfseries "\backwhack{}x03bb;"}. Окончание строки,
находящееся не за обратным слешем, обозначает символ linefeed.

%Examples:
Примеры:

\texonly
\begin{tabbing}
{\cf "\backwhack{}x0000000000;"} \=\kill
\endtexonly
\htmlonly
\begin{tabular}{ll}
\endhtmlonly
{\bfseries\cf "abc"} \extab  \textrm{U+0061, U+0062, U+0063}\\
{\bfseries\cf "\backwhack{}x41;bc"} \extab  {\bfseries\cf "Abc"} ; \textrm{U+0041, U+0062, U+0063}\\
{\bfseries\cf "\backwhack{}x41; bc"} \extab {\bfseries\cf "A bc"}\\
 \extab U+0041, U+0020, U+0062, U+0063\\
{\bfseries\cf "\backwhack{}x41bc;"} \extab  \textrm{U+41BC}\\
{\bfseries\cf "\backwhack{}x41"} \extab \exception{\bfseries\&lexical}\\
{\bfseries\cf "\backwhack{}x;"} \extab \exception{\bfseries\&lexical}\\
{\bfseries\cf "\backwhack{}x41bx;"} \extab \exception{\bfseries\&lexical}\\
{\bfseries\cf "\backwhack{}x00000041;"} \extab  {\bfseries\cf "A"} ; \textrm{U+0041}\\
{\bfseries\cf "\backwhack{}x0010FFFF;"} \extab \textrm{U+10FFFF}\\
{\bfseries\cf "\backwhack{}x00110000;"} \extab  \exception{\bfseries\&lexical}\\
 \extab out of range\\
{\bfseries\cf "\backwhack{}x000000001;"} \extab \textrm{U+0001}\\
{\bfseries\cf "\backwhack{}xD800;"} \extab \exception{\bfseries\&lexical}\\
 \extab in excluded range\\
{\bfseries\cf "A}\\
{\bfseries\cf bc"} \extab \textrm{U+0041, U+000A, U+0062, U+0063}\\
 \extab if no space occurs after the {\bfseries\cf{}A}
\htmlonly
\end{tabular}
\endhtmlonly
\texonly
\end{tabbing}
\endtexonly

%\subsection{Numbers}
\subsection{Числа}
\label{numbernotations}

%The syntax of external representations for number objects is described
%formally by the \meta{number} rule in the formal grammar.
%Case is not significant in external representations of number objects.
Синтаксис внешних представлений числовых объектов формально описан правилом \meta{number}
формальной грамматики. Во внешних представлениях числовых объектов регистр является незначащим.

%A representation of a number object may be written in binary, octal, decimal, or
%hexadecimal by the use of a radix prefix.  The radix prefixes are {\cf
%\#b}\sharpindex{b} (binary), {\cf \#o}\sharpindex{o} (octal), {\cf
%\#d}\sharpindex{d} (decimal), and {\cf \#x}\sharpindex{x} (hexadecimal).  With
%no radix prefix, a representation of a number object is assumed to be expressed in decimal.
Представление числового объекта может быть записано в двоичном, восьмеричном, десятичном или
шестнадцатеричном виде при помощи приставки основания. Приставками основания являются
{\bfseries\cf \#b}\sharpindex{b} (двоичная), {\bfseries\cf \#o}\sharpindex{o} (восьмеричная),
{\bfseries\cf \#d}\sharpindex{d} (десятичная) и {\bfseries\cf \#x}\sharpindex{x}
(шестнадцатеричная). Без приставки основания представление числового объекта предполагается
выраженным в десятичном виде.

%A representation of a number object may be specified to be either exact or
%inexact by a prefix.  The prefixes are {\cf \#e}\sharpindex{e}
%for exact, and {\cf \#i}\sharpindex{i} for inexact.  An exactness
%prefix may appear before or after any radix prefix that is used.  If
%the representation of a number object has no exactness prefix, the
%constant is
%inexact if it contains a decimal point, an
%exponent, or
%a nonempty mantissa width;
%otherwise it is exact.
Представление числового объекта может указываться точным или неточным с помощью
приставки. Приставками являются {\bfseries\cf \#e}\sharpindex{e} для точного и {\bfseries\cf
  \#i}\sharpindex{i} для неточного. Приставка точности может находиться до или после любой
используемой приставки основания. Если представление числового объекта не содержит приставки
точности, константа является неточной, если она содержит десятичную точку, экспоненту или
непустую ширину мантиссы; в противном случае она является точной.

%In systems with inexact number objects
%of varying precisions, it may be useful to specify
%the precision of a constant.  For this purpose, representations of
%number objects
%may be written with an exponent marker that indicates the
%desired precision of the inexact
%representation.  The letters {\cf s}, {\cf f},
%{\cf d}, and {\cf l} specify the use of \var{short}, \var{single},
%\var{double}, and \var{long} precision, respectively.  (When fewer
%than four internal
%inexact
%representations exist, the four size
%specifications are mapped onto those available.  For example, an
%implementation with two internal representations may map short and
%single together and long and double together.)  In addition, the
%exponent marker {\cf e} specifies the default precision for the
%implementation.  The default precision has at least as much precision
%as \var{double}, but
%implementations may wish to allow this default to be set by the user.
В системах с неточными числовыми объектами переменной точности может быть полезно определение
точности константы. С этой целью представления числовых объектов могут записываться с
экспоненциальным маркером, указывающим желаемую точность неточного представления. Буквы
{\bfseries\cf s}, {\bfseries\cf f}, {\bfseries\cf d} и {\bfseries\cf l} указывают на использование
точности \var{short}, \var{single}, \var {double} и \var{long} соответственно. (Если существует
менее четырёх внутренних неточных представлений, четыре спецификации размера преобразовываются в
доступные. Например, реализация с двумя внутренними представлениями может преобразовывать вместе
short и single, а также long и double) Кроме того, маркер точности {\bfseries\cf e} указывает
точность по умолчанию для реализации. Точность по умолчанию имеет значение по крайней мере не
менее точности \var{double}, но реализации могут позволять пользователю устанавливать данное
умолчание.

\begin{scheme}
\bfseries 3.1415926535898F0
       {\rm{}Round to single, perhaps} {\bfseries 3.141593}
\bfseries 0.6L0
       {\rm{}Extend to long, perhaps} {\bfseries .600000000000000}%
\end{scheme}

%A representation of a number object with nonempty mantissa width,
%{\cf \var{x}|\var{p}}, represents the best binary
%floating-point approximation of \var{x} using a \var{p}-bit significand.
%For example, {\cf 1.1|53} is a
%representation of the best approximation of 1.1 in IEEE double
%precision.
%If \var{x} is an external representation of an inexact real number object
%that contains no vertical bar, then its numerical value should be computed
%as though it had a mantissa width of 53 or more.
Представление числового объекта с непустой шириной мантиссы {\cf \var{x}|\var{p}} представляет
наилучшее двоичное приближение с плавающей точкой \var{x} с помощью \var{p}-битной значащей
части. Например, {\cf\bfseries 1.1|53} является представлением наилучшего приближения 1.1 в IEEE
двойной точности. Если \var{x} является внешним представлением неточного действительного
числового объекта, не содержащим вертикальной черты, его численное значение должно
вычисляться так, как если бы оно имело ширину мантиссы 53 или более.

%Implementations that use binary floating-point representations
%of real number objects should represent {\cf \var{x}|\var{p}}
%using a \var{p}-bit significand if practical, or by a greater
%precision if a \var{p}-bit significand is not practical, or
%by the largest available precision if \var{p} or more bits
%of significand are not practical within the implementation.
Реализации, использующие двоичные представления с плавающей точкой действительных числовых
объектов, должны представлять {\cf \var{x}|\var{p}} с помощью \var{p}-битной значащей части,
если это удобно, или с большей точностью, если \var{p}-битная значащая часть не
удобна, или с наибольшей доступной точностью, если \var{p} или более бит
значащей части не удобны в реализации.

\begin{note}
%The precision of a significand should not be confused with the
%number of bits used to represent the significand.  In the IEEE
%floating-point standards, for example, the significand's most
%significant bit is implicit in single and double precision but
%is explicit in extended precision.  Whether that bit is implicit
%or explicit does not affect the mathematical precision.
%In implementations that use binary floating point, the default
%precision can be calculated by calling the following procedure:
Точность значащей части не следует путать с количеством бит, используемых для представления
значащей части. В стандартах IEEE с плавающей точкой, например, старший значащий бит значащей
части является неявным при одинарной и двойной точности, и явным при расширенной точности. На
математическую точность не влияет, является ли этот бит явным или неявным. В реализациях,
использующих двоичную плавающую точку, точность по умолчанию может быть вычислена путём вызова
следующей процедуры:

\begin{scheme}
\bfseries (define (precision)
\bfseries   (do ((n 0 (+ n 1))
\bfseries        (x 1.0 (/ x 2.0)))
\bfseries     ((= 1.0 (+ 1.0 x)) n)))
\end{scheme}
\end{note}

\begin{note}
%When the underlying floating-point representation is IEEE double
%precision, the {\cf |\var{p}} suffix should not always be omitted:
%Denormalized floating-point numbers have diminished precision,
%and therefore their external representations should
%carry a {\cf |\var{p}} suffix with the actual width of the
%significand.
Если основным представлением с плавающей точкой является двойная точность IEEE, {\cf |\var{p}},
суффикс не должен всегда быть пропущеным: Денормализованные числа с плавающей точкой имеют пониженную
точность, и поэтому их внешние представления должны содержать суффикс {\cf |\var{p}} с
фактической шириной значащей части.
\end{note}

%The literals {\cf +inf.0} and {\cf -inf.0} represent positive and
%negative infinity, respectively.  The {\cf +nan.0}
%literal represents the NaN that is the result of {\cf (/ 0.0 0.0)},
%and may represent other NaNs as well.
Литералы {\cf\bfseries +inf.0} и {\cf\bfseries -inf.0} представляют положительную и
отрицательную бесконечность соответственно. Литерал {\cf\bfseries +nan.0} представляет NaN,
являющийся результатом {\cf\bfseries(/ 0.0 0.0)}, и может также представлять другие NaN.

%If \var{x} is an external representation of an inexact real number
%object and
%contains no vertical bar and no exponent marker
%other than {\cf e}, the inexact real number object it represents is a flonum
%(see library section~\extref{lib:flonumssection}{Flonums}).
%Some or all of the other external representations of
%inexact real number objects may also represent flonums, but that is not required by
%this report.
Если \var{x} является внешним представлением неточного действительного числового объекта и не
содержит вертикальной черты и экспоненциального маркера кроме {\cf\bfseries e}, неточным
действительным числовым объектом, представляющим его, является flonum (см. секцию
библиотек~\extref{lib:flonumssection}{Flonums}). Некоторые или все другие внешние представления
неточных действительных числовых объектов могут также представлять flonums, но это не является
требованием данной работы.

%\section{Datum syntax}
\section{Datum-синтаксис}
\label{datumsyntaxsection}

%The datum syntax describes the syntax of
%syntactic data\mainindex{syntactic datum} in terms of a sequence of
%\meta{lexeme}s, as defined in the lexical syntax.
Datum-синтаксис описывает синтаксис синтаксических данных\mainindex{syntactic datum}
в терминах последовательности \meta{лексем} как определено в лексическом
синтаксисе.

%Syntactic data include the lexeme data described in the
%previous section as well as the following constructs for forming
%compound data:
Синтаксические данные включают данные лексем, описанные в предыдущих секциях, а также
следующие конструкции для формирования составных данных:
%
\begin{itemize}
%\item pairs and lists, enclosed by \verb|( )| or \verb|[ ]| (see
%  section~\ref{pairlistsyntax})
\item пары и списки, заключённые в \verb|( )| или \verb|[ ]| (см.
  секцию~\ref{pairlistsyntax})
%\item vectors (see section~\ref{vectorsyntax})
\item векторы (см. секцию~\ref{vectorsyntax})
%\item bytevectors (see section~\ref{bytevectorsyntax})
\item байтовые векторы (см. секцию~\ref{bytevectorsyntax})
\end{itemize}

%\subsection{Formal account}
\subsection{Формальное описание}
\label{datumsyntax}

%The following grammar describes the syntax of syntactic data in terms
%of various kinds of lexemes defined in the grammar in
%section~\ref{lexicalsyntaxsection}:
Следующая грамматика описывает синтаксис синтаксических данных в терминах лексем различных видов,
определённых в грамматике в секции ~\ref{lexicalsyntaxsection}:

\begin{grammar}%
\meta{datum} \: \meta{lexeme datum}
\>  \| \meta{compound datum}
\meta{lexeme datum} \: \meta{boolean} \| \meta{number}
\>  \| \meta{character} \| \meta{string} \|  \meta{symbol}
\meta{symbol} \: \meta{identifier}
\meta{compound datum} \: \meta{list} \| \meta{vector} \| \meta{bytevector}
\meta{list} \: (\arbno{\meta{datum}}) \| [\arbno{\meta{datum}}]
\>    \| (\atleastone{\meta{datum}} .\ \meta{datum}) \| [\atleastone{\meta{datum}} .\ \meta{datum}]
\>    \| \meta{abbreviation}
\meta{abbreviation} \: \meta{abbrev prefix} \meta{datum}
\meta{abbrev prefix} \: ' \| ` \| , \| ,@
\>    \| \#' | \#` | \#, | \#,@
\meta{vector} \: \#(\arbno{\meta{datum}})
\meta{bytevector} \: \#vu8(\arbno{\meta{u8}})
\meta{u8} \: $\langle${\rm any \meta{number} representing an exact}
 \>\>\quad\quad {\rm integer in $\{0, \ldots, 255\}$}$\rangle$%
\end{grammar}

%\subsection{Pairs and lists}
\subsection{Пары и списки}
\label{pairlistsyntax}

%List and pair data, representing pairs and lists of values
%(see section~\ref{listsection}) are represented using parentheses or brackets.
%Matching pairs of brackets that occur in the rules of \meta{list} are
%equivalent to matching pairs of parentheses.
Данные списков и пар, представляющие значения пар и списков (см. секцию~\ref{listsection}),
представляются с помощью круглых или квадратных скобок. Соответствие пар квадратных скобок,
находящихся в правилах \meta{list}, эквивалентно соответствию пар круглых
скобок.

\newpage

%The most general notation for Scheme pairs as syntactic data is
%the ``dotted'' notation \hbox{\cf (\hyperi{datum} .\ \hyperii{datum})} where
%\hyperi{datum} is the representation of the value of the car field and
%\hyperii{datum} is the representation of the value of the
%cdr field.  For example {\cf (4 .\ 5)} is a pair whose car is 4 and whose
%cdr is 5.
Наиболее общей нотацией для пар Scheme как синтаксических данных является ``точечная'' нотация
\hbox{\cf (\hyperi{datum} .\ \hyperii{datum})}, где \hyperi{datum} является представлением
значения car, а \hyperii{datum} - значения поля cdr. Например, {\cf\bfseries (4 .\ 5)} является
парой, car которой - 4, а cdr - 5.

%A more streamlined notation can be used for lists: the elements of the
%list are simply enclosed in parentheses and separated by spaces.  The
%empty list\index{empty list} is represented by {\tt()} .  For example,
Для списков может использоваться более чёткая нотация: элементы списка просто заключаются в
круглые скобки и разделяются пробелами. Пустой список\index{empty list} представляется, как
{\tt()}. Например,

\begin{scheme}
\bfseries(a b c d e)%
\end{scheme}

%and
и

\begin{scheme}
\bfseries (a . (b . (c . (d . (e . ())))))%
\end{scheme}

%are equivalent notations for a list of symbols.
являются эквивалентными формами записи списка символов

%The general rule is that, if a dot is followed by an open parenthesis,
%the dot, open parenthesis, and matching closing parenthesis
%can be omitted in the external representation.
Общее правило гласит, что если за точкой следует открывающаяся круглая скобка, точка,
открывающаяся круглая скобка и соответствующая ей закрывающаяся круглая скобка
во внешнем представлении могут быть пропущены.

%The sequence of characters ``{\cf (4 .\ 5)}'' is the external representation of a
%pair, not an expression that evaluates to a pair.
%Similarly, the sequence of characters ``{\tt(+ 2 6)}'' is {\em not} an
%external representation of the integer 8, even though it {\em is} an
%expression (in the language of the \rsixlibrary{base} library)
%evaluating to the integer 8; rather, it is a
%syntactic datum representing a three-element list, the elements of which
%are the symbol {\tt +} and the integers 2 and 6.
Последовательность символов ``{\cf\bfseries (4 .\ 5)}'' является внешним представлением пары, а не
выражением, которое вычисляется как пара. Аналогично, последовательность символов ``{\tt\bfseries (+ 2 6)}''
{\em не} является внешним представлением целого числа 8, даже при том, что она {\em является} выраженим
(на языке библиотеки {\bfseries\rsixlibrary{base}}), вычисляемым как целое число 8; наоборот, это
синтаксический datum, представляющий трёхэлементный список, элементами которого являются
символ {\tt\bfseries +} и целые числа 2 и 6.

%\subsection{Vectors}
\subsection{Векторы}
\label{vectorsyntax}

%Vector data, representing vectors of objects (see
%section~\ref{vectorsection}), are represented using the notation
%{\tt\#(\hyper{datum} \dotsfoo)}.  For example, a vector of length 3
%containing the number object for zero in element 0, the list {\cf(2 2 2 2)} in
%element 1, and the string {\cf "Anna"} in element 2 can be represented as
%follows:
Векторные данные, представляюшие вектора объектов (см. секцию~\ref{vectorsection}),
представляются с помощью нотации {\tt{\bfseries\#(}\hyper{datum}
  \dotsfoo{\bfseries)}}. Например, вектор с длиной 3, содержащий числовой объект для нуля в
элементе 0, список {\cf\bfseries (2 2 2 2)} в элементе 1 и строку {\cf\bfseries "Анна"} в
элементе 2, может быть представлен следующим образом:

\begin{scheme}
\bfseries \#(0 (2 2 2 2) "Anna")%
\end{scheme}

%This is the external representation of a vector, not an
%expression that evaluates to a vector.
Это внешнее представление вектора, а не выражение, вычисляемое как вектор.

%\subsection{Bytevectors}
\subsection{Байтовые векторы}
\label{bytevectorsyntax}

%Bytevector data, representing bytevectors (see
%library chapter~\extref{lib:bytevectorschapter}{Bytevectors}), are represented using the notation
%{\tt\#vu8(\hyper{u8} \dotsfoo)}, where the \hyper{u8}s represent the octets of
%the bytevector.  For example, a bytevector of length 3 containing the
%octets 2, 24, and 123 can be represented as follows:
Байт-векторные данные, представляющие байтовые вектора (см. библиотечную
главу~\extref{lib:bytevectorschapter}{Bytevectors}), представляются с помощью нотации
{\tt{\bfseries\#vu8(}\hyper{u8} \dotsfoo{\bfseries )}}, где \hyper{u8} представляет октет
байтового вектора. Например, байтовый вектор с длиной 3, содержащий октеты 2, 24 и 123, может быть
представлен следующим образом:

\begin{scheme}
\bfseries \#vu8(2 24 123)%
\end{scheme}

%This is the external representation of a bytevector, and also an
%expression that evaluates to a bytevector.
Это внешнее представление байтового вектора, а не выражение, вычисляемое как байтовый вектор.

%\subsection{Abbreviations}\unsection
\subsection{Сокращения}\unsection
\label{abbreviationsection}

\begin{entry}{%
\pproto{\singlequote\hyper{datum}}{}
\pproto{\backquote\hyper{datum}}{}
\pproto{,\hyper{datum}}{}
\pproto{,\atsign\hyper{datum}}{}
\pproto{\#'\hyper{datum}}{}
\pproto{\#\backquote\hyper{datum}}{}
\pproto{\#,\hyper{datum}}{}
\pproto{\#,@\hyper{datum}}{}
}

%Each of these is an abbreviation:
Каждый из них является сокращением:
\\\quad\schindex{'}\singlequote\hyper{datum}
for {\cf (quote \hyper{datum})},
\\\quad\schindex{`}\backquote\hyper{datum}
for {\cf (quasiquote \hyper{datum})},
\\\quad\schindex{,}{\cf,}\hyper{datum}
for {\cf (unquote \hyper{datum})},
\\\quad\index{,@\texttt{,\atsign}}{\cf,}\atsign\hyper{datum}
for {\cf (unquote-splicing \hyper{datum})},
\\\quad\sharpindex{'}{\cf\#'}\hyper{datum}
for {\cf (syntax \hyper{datum})},
\\\quad\sharpindex{`}{\cf\#`}\hyper{datum}
for {\cf (quasisyntax \hyper{datum})},
\\\quad\sharpindex{,}{\cf\#,}\hyper{datum}
for {\cf (unsyntax \hyper{datum})}, and
\\\quad\index{#,@\texttt{\#,\atsign}}{\cf\#,@}\hyper{datum}
for {\cf (unsyntax-splicing \hyper{datum})}.
\end{entry}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End:
