<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from r6rs-rationale.tex by tex2page, v 20070803
(running on MzScheme 371, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
Revised^6 Report on the Algorithmic Language Scheme - Non-Normative Appendices -
</title>
<link rel="stylesheet" type="text/css" href="r6rs-rationale-Z-S.css" title=default>
<meta name=robots content="index,follow">
</head>
<body>
<div id=slidecontent>
<div align=right class=navigation>[Go to <span><a href="r6rs-rationale.html">first</a>, <a href="r6rs-rationale-Z-H-15.html">previous</a></span><span>, <a href="r6rs-rationale-Z-H-17.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="r6rs-rationale-Z-H-2.html#node_toc_start">contents</a></span>]</div>
<p></p>
<a name="node_chap_14"></a>
<h1 class=chapter>
<div class=chapterheading><a href="r6rs-rationale-Z-H-2.html#node_toc_node_chap_14">Chapter 14</a></div><br>
<a href="r6rs-rationale-Z-H-2.html#node_toc_node_chap_14">Bytevectors</a></h1>
<p>Bytevectors are a representation for binary data, based on
SRFI&nbsp;74&nbsp;[<a href="r6rs-rationale-Z-H-31.html#node_bib_32">32</a>].  The primary motivation for including them in
R<sup>6</sup>RS was to enable binary I/O.  Positions in bytevectors always
refer to certain bytes or octets.  However, the operations of the
<tt>(rnrs bytevectors (6))</tt> library provide access to binary data in
various byte-aligned formats, such as signed and unsigned integers of
various widths, IEEE floating-point representations, and textual
encodings.  This differs notably from representations for binary data
as homogeneous vectors of numbers.  In settings related to I/O, an
application often needs to access different kinds of entities from a
single binary block.  Providing operations for them on a single
datatype considerably reduces both programming effort and library
size.</p>
<p>
Bytevectors can also be used to encode sequences of unboxed number objects.
Unencapsulated use of bytevectors for this purpose may lead
to aliasing, which may reduce the effectiveness of compiler
optimizations.  However, sealedness and
opacity of records, together with bytevectors, make it possible to
construct a portable implementation for new data types that
provides fast and memory-efficient arrays of homogeneous numerical
data.</p>
<p>
</p>
<div class=smallskip></div>
<p style="margin-top: 0pt; margin-bottom: 0pt">
<div align=right class=navigation>[Go to <span><a href="r6rs-rationale.html">first</a>, <a href="r6rs-rationale-Z-H-15.html">previous</a></span><span>, <a href="r6rs-rationale-Z-H-17.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="r6rs-rationale-Z-H-2.html#node_toc_start">contents</a></span>]</div>
</p>
<p></p>
</div>
</body>
</html>
